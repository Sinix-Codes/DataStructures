{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Data Structures Documentation by Kunal Khairnar","text":""},{"location":"#hey-folks","title":"Hey Folks","text":""},{"location":"#im-kunal-khairnar-computer-engineering-student-at-government-polytechnic-pune","title":"I'm Kunal Khairnar, Computer Engineering Student at Government Polytechnic Pune .","text":""},{"location":"#im-a-cc-javajavascript-and-python-learner-and-developer","title":"I'm a C/C++, Java,JavaScript and Python learner and Developer .","text":""},{"location":"#im-also-a-competitive-programmer","title":"I'm also a Competitive Programmer .","text":""},{"location":"#im-also-a-web-developer","title":"I'm also a Web Developer .","text":""},{"location":"#im-also-a-data-structures-and-algorithms-enthusiast","title":"I'm also a Data Structures and Algorithms Enthusiast .","text":""},{"location":"#im-also-a-open-source-contributor","title":"I'm also a Open Source Contributor.","text":""},{"location":"#data-structures","title":"Data Structures","text":"<p>Data structures are a way of organizing data in such a way that we can perform operations on these data in an effective way. Data structures are used to store collection of data, the relationship among them, and the functions or operations that can be applied to the data.</p>"},{"location":"#types-of-data-structures","title":"Types of Data Structures","text":"<p>There are two types of data structures:</p> <ul> <li> <p>Linear Data Structures</p> </li> <li> <p>Non-Linear Data Structures</p> </li> </ul>"},{"location":"Data-Type/Data-type/","title":"Data Types in C &amp; C++","text":""},{"location":"Data-Type/Data-type/#type-of-primary-data","title":"Type of Primary Data","text":"<p>A fundamental or primitive data type is a form of built-in data that a programming language offers for use in the construction of more sophisticated data structures. Four data types that participate in several data formats are considered primitive data types.</p>"},{"location":"Data-Type/Data-type/#integer","title":"* Integer *","text":"<p>An integer data type is used to represent variables that have numeric values or have no values at all. Such data types without values may have their range designated as \"short\" or \"long\" depending on the requirements of the programme. The keyword \"int\" indicates that a value is of the integer data type.</p>"},{"location":"Data-Type/Data-type/#character","title":"* Character *","text":"<p>Characters of a specific length are included in character data types. Anything from letters, numbers, and symbols are permitted. An integral-type value can only be contained in char, which has a 1 byte capacity limit. Char is a data type.</p>"},{"location":"Data-Type/Data-type/#floating-point","title":"* Floating Point *","text":"<p>Floating-point data types are used to represent real numbers. The keyword \"float\" indicates that a value is of the floating-point data type. The keyword \"double\" indicates that a value is of the double-precision floating-point data type. The keyword \"long double\" indicates that a value is of the long double-precision floating-point data type.</p>"},{"location":"Data-Type/Data-type/#boolean","title":"* Boolean *","text":"<p>Boolean data types are used to represent variables that have a value of either true or false. The keyword \"bool\" indicates that a value is of the boolean data type.</p>"},{"location":"Data-Type/Data-type/#type-of-derived-data","title":"* Type of Derived Data *","text":"<p>Derived data types are data types that are constructed from the primitive data types. The derived data types are arrays, structures, unions, and pointers.</p>"},{"location":"Data-Type/Data-type/#array","title":"* Array *","text":"<p>An array is a collection of data items of the same type. The data items are stored in contiguous memory locations. The array is a derived data type.</p>"},{"location":"Data-Type/Data-type/#structure","title":"* Structure *","text":"<p>A structure is a collection of data items of different types. The data items are stored in contiguous memory locations. The structure is a derived data type.</p>"},{"location":"Data-Type/Data-type/#union","title":"* Union *","text":"<p>A union is a collection of data items of different types. The data items are stored in the same memory location. The union is a derived data type.</p>"},{"location":"Data-Type/Data-type/#pointer","title":"* Pointer *","text":"<p>A pointer is a variable that stores the address of another variable. The pointer is a derived data type.</p>"},{"location":"Data-Type/Data-type/#type-of-abstract-data","title":"Type of Abstract Data","text":"<p>Abstract data types are data types that are defined by their behaviour from the point of view of the user. The abstract data types are functions, files, and records.</p>"},{"location":"Data-Type/Data-type/#function","title":"* Function *","text":"<p>A function is a group of statements that perform a specific task. The function is an abstract data type.</p>"},{"location":"Data-Type/Data-type/#file","title":"* File *","text":"<p>A file is a collection of data items of the same type. The data items are stored in a file. The file is an abstract data type.</p>"},{"location":"Data-Type/Data-type/#record","title":"* Record *","text":"<p>A record is a collection of data items of different types. The data items are stored in a record. The record is an abstract data type.</p>"},{"location":"Data-Type/Data-type/#type-of-user-defined-data","title":"Type of User-Defined Data","text":"<p>User-defined data types are data types that are defined by the user. The user-defined data types are enumerated, typedef, and class.</p>"},{"location":"Data-Type/Data-type/#enumerated","title":"Enumerated","text":"<p>An enumerated data type is a data type that is defined by a list of names called enumerators. The enumerated data type is a user-defined data type.</p>"},{"location":"Data-Type/Data-type/#typedef","title":"Typedef","text":"<p>A typedef data type is a data type that is defined by a keyword. The typedef data type is a user-defined data type.</p>"},{"location":"Data-Type/Data-type/#class","title":"Class","text":"<p>A class is a data type that is defined by a keyword. The class is a user-defined data type.</p>"},{"location":"Data-Type/Data-type/#type-of-special-data","title":"Type of Special Data","text":"<p>Special data types are data types that are defined by the compiler. The special data types are void, auto, register, static, extern, mutable, and volatile.</p>"},{"location":"Data-Type/Data-type/#void","title":"Void","text":"<p>A void data type is a data type that is defined by the compiler. The void data type is a special data type.</p>"},{"location":"Data-Type/Data-type/#auto","title":"Auto","text":"<p>An auto data type is a data type that is defined by the compiler. The auto data type is a special data type.</p>"},{"location":"Data-Type/Data-type/#register","title":"Register","text":"<p>A register data type is a data type that is defined by the compiler. The register data type is a special data type.</p>"},{"location":"Data-Type/Data-type/#static","title":"Static","text":"<p>A static data type is a data type that is defined by the compiler. The static data type is a special data type.</p>"},{"location":"Data-Type/Data-type/#extern","title":"Extern","text":"<p>An extern data type is a data type that is defined by the compiler. The extern data type is a special data type.</p>"},{"location":"Data-Type/Data-type/#mutable","title":"Mutable","text":"<p>A mutable data type is a data type that is defined by the compiler. The mutable data type is a special data type.</p>"},{"location":"Data-Type/Data-type/#volatile","title":"Volatile","text":"<p>A volatile data type is a data type that is defined by the compiler. The volatile data type is a special data type.</p>"},{"location":"Data-Type/Data-type/#type-of-data-type","title":"Type of Data Type","text":"<p>Data types are classified into two types: built-in data types and user-defined data types.</p>"},{"location":"Data-Type/Data-type/#built-in-data-types","title":"Built-in Data Types","text":"<p>Built-in data types are data types that are defined by the programming language. The built-in data types are primitive data types, derived data types, abstract data types, and special data types.</p>"},{"location":"Data-Type/Data-type/#user-defined-data-types","title":"User-Defined Data Types","text":"<p>User-defined data types are data types that are defined by the user. The user-defined data types are enumerated data types, typedef data types, and class data types.</p>"},{"location":"Data-Type/Data-type/#type-of-data-type-modifier","title":"Type of Data Type Modifier","text":"<p>Data type modifiers are used to modify the data types. The data type modifiers are signed, unsigned, short, long, and const.</p>"},{"location":"Data-Type/Data-type/#signed","title":"Signed","text":"<p>A signed data type modifier is used to modify the data types. The signed data type modifier is a data type modifier.</p>"},{"location":"Data-Type/Data-type/#unsigned","title":"Unsigned","text":"<p>An unsigned data type modifier is used to modify the data types. The unsigned data type modifier is a data type modifier.</p>"},{"location":"Data-Type/Data-type/#short","title":"Short","text":"<p>A short data type modifier is used to modify the data types. The short data type modifier is a data type modifier.</p>"},{"location":"Data-Type/Data-type/#long","title":"Long","text":"<p>A long data type modifier is used to modify the data types. The long data type modifier is a data type modifier.</p>"},{"location":"Data-Type/Data-type/#const","title":"Const","text":"<p>A const data type modifier is used to modify the data types. The const data type modifier is a data type modifier.</p>"},{"location":"Data-Type/Data-type/#type-of-data-type-qualifier","title":"Type of Data Type Qualifier","text":"<p>Data type qualifiers are used to qualify the data types. The data type qualifiers are volatile and restrict.</p>"},{"location":"Data-Type/Data-type/#volatile_1","title":"Volatile","text":"<p>A volatile data type qualifier is used to qualify the data types. The volatile data type qualifier is a data type qualifier.</p>"},{"location":"Data-Type/Data-type/#restrict","title":"Restrict","text":"<p>A restrict data type qualifier is used to qualify the data types. The restrict data type qualifier is a data type qualifier.</p>"},{"location":"Dynamic_Memory_Allocation/Dynamic_Memory_Allocation/","title":"Dynamic Memory Allocation","text":"<p>Dynamic memory allocation is the process of allocating memory during the runtime of a program. This is in contrast to static memory allocation, where memory is allocated at compile time. Dynamic memory allocation is useful when the size of the memory required is not known until the program is running. For example, a program may need to read in a large amount of data from a file, and the amount of data is not known until the program is running. In this case, the program can allocate the memory it needs at runtime.</p>"},{"location":"Dynamic_Memory_Allocation/Dynamic_Memory_Allocation/#the-malloc-function-and-the-free-function","title":"\u2022 The <code>malloc</code> Function and the <code>free</code> Function","text":"<p>The <code>malloc</code> function is used to dynamically allocate a single block of memory. The function takes a single argument, which is the size of the memory block to be allocated, in bytes. The function returns a pointer to the allocated memory block. The pointer returned by <code>malloc</code> is of type <code>void *</code>, which means that it can be cast to a pointer of any type. For example, if you want to allocate memory for an array of <code>int</code>s, you can cast the pointer returned by <code>malloc</code> to a pointer of type <code>int *</code>.</p> <pre><code>    #include&lt;stdlib.h&gt;\n\n    int main(void)\n    {\n        int *p = (int *)malloc(10 * sizeof(int));\n        if (p == NULL)\n        {\n            // Handle error\n        }\n\n        // Use p\n\n        free(p);\n\n        return 0;\n    }\n</code></pre>"},{"location":"Dynamic_Memory_Allocation/Dynamic_Memory_Allocation/#the-calloc-function","title":"\u2022 The <code>calloc</code> Function","text":"<p>The <code>calloc</code> function is similar to the <code>malloc</code> function, except that it initializes the memory block to zero. The function takes two arguments: the number of elements to be allocated, and the size of each element, in bytes. The function returns a pointer to the allocated memory block. The pointer returned by <code>calloc</code> is of type <code>void *</code>, which means that it can be cast to a pointer of any type. For example, if you want to allocate memory for an array of <code>int</code>s, you can cast the pointer returned by <code>calloc</code> to a pointer of type <code>int *</code>.</p> <pre><code>    #include&lt;stdlib.h&gt;\n\n    int main(void)\n    {\n        int *p = (int *)calloc(10, sizeof(int));\n        if (p == NULL)\n        {\n            // Handle error\n        }\n\n        // Use p\n\n        free(p);\n\n        return 0;\n    }\n</code></pre>"},{"location":"Dynamic_Memory_Allocation/Dynamic_Memory_Allocation/#the-realloc-function","title":"\u2022 The <code>realloc</code> Function","text":"<p>The <code>realloc</code> function is used to change the size of a previously allocated memory block. The function takes two arguments: a pointer to the previously allocated memory block, and the new size of the memory block, in bytes. The function returns a pointer to the newly allocated memory block. The pointer returned by <code>realloc</code> is of type <code>void *</code>, which means that it can be cast to a pointer of any type. For example, if you want to allocate memory for an array of <code>int</code>s, you can cast the pointer returned by <code>realloc</code> to a pointer of type <code>int *</code>.</p> <pre><code>    #include&lt;stdlib.h&gt;\n\n    int main(void)\n    {\n        int *p = (int *)malloc(10 * sizeof(int));\n        if (p == NULL)\n        {\n            // Handle error\n        }\n\n        // Use p\n\n        p = (int *)realloc(p, 20 * sizeof(int));\n        if (p == NULL)\n        {\n            // Handle error\n        }\n\n        // Use p\n\n        free(p);\n\n        return 0;\n    }\n</code></pre>"},{"location":"Hashing/Hashing/","title":"Hash table #","text":"<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;stdbool.h&gt;\n\n#define MAX_NAME 256\n#define TABLE_SIZE 5\n#define DELETED_NODE (person *)(0xFFFFFFFFFFFFFFFF)\n\ntypedef struct person_tag\n{\n    char name[MAX_NAME];\n    struct person_tag *next;\n} person;\n\nperson *hash_table[TABLE_SIZE];\nperson **persons = NULL;\nint n_persons = 0;\n\nunsigned int hash(const char *name)\n{\n    int length = strnlen(name, MAX_NAME);\n    unsigned int hash_value = 0;\n\n    for (int i = 0; i &lt; length; i++)\n    {\n        hash_value += name[i];\n        hash_value = (hash_value * name[i]) % TABLE_SIZE; // just to produce more random hash values\n    }\n\n    return hash_value;\n}\n\nvoid init_hash_table()\n{\n    // Set the bits of hash table to 0\n    memset(hash_table, 0, sizeof(hash_table));\n}\n\nvoid print_table()\n{\n    person *temp = NULL;\n\n    printf(\"Start\\n\");\n    for (int i = 0; i &lt; TABLE_SIZE; i++)\n    {\n        if (hash_table[i] == NULL)\n        {\n            printf(\"\\t%i\\t---\\n\", i);\n        }\n        else if (hash_table[i] == DELETED_NODE)\n        {\n            printf(\"\\t%i\\t---&lt;Deleted&gt;\\n\", i);\n        }\n        else\n        {\n            printf(\"\\t%i\\t%s \", i, hash_table[i]-&gt;name);\n\n            temp = hash_table[i]-&gt;next;\n            while (temp != NULL)\n            {\n                printf(\"-&gt; %s \", temp-&gt;name);\n                temp = temp-&gt;next;\n            }\n\n            printf(\"\\n\");\n        }\n    }\n    printf(\"End\\n\");\n}\n\nbool hash_table_insert(person *p)\n{\n    person *temp = NULL;\n    if (p == NULL)\n    {\n        return false;\n    }\n\n    int index = hash(p-&gt;name) % TABLE_SIZE;\n\n    if (hash_table[index] == NULL)\n    {\n        hash_table[index] = p;\n    }\n    else\n    {\n        temp = hash_table[index];\n        while (temp-&gt;next != NULL)\n        {\n            temp = temp-&gt;next;\n        }\n\n        temp-&gt;next = p;\n    }\n\n    n_persons++;\n    return true;\n}\n\n// finds a person in the hash table by their name\nperson *hash_table_lookup(const char *name)\n{\n    int index = hash(name) % TABLE_SIZE;\n    person *temp = hash_table[index];\n    while (temp != NULL &amp;&amp; strcmp(temp-&gt;name, name) != 0)\n    {\n        temp = temp-&gt;next;\n    }\n\n    return temp;\n}\n\n// deletes a person from the hash table by their name\nperson *hash_table_delete(const char *name)\n{\n    int index = hash(name) % TABLE_SIZE;\n\n    person *tmp = hash_table[index];\n    person *prev = NULL;\n\n    while (tmp != NULL &amp;&amp; strcmp(tmp-&gt;name, name) != 0)\n    {\n        prev = tmp;\n        tmp = tmp-&gt;next;\n    }\n\n    if (tmp == NULL)\n    {\n        return NULL;\n    }\n\n    if (prev == NULL)\n    {\n        if (tmp-&gt;next == NULL)\n            hash_table[index] = DELETED_NODE; // deleting head\n        else\n            hash_table[index] = tmp-&gt;next; // deleting head\n    }\n    else\n    {\n        prev-&gt;next = tmp-&gt;next;\n    }\n\n    return tmp;\n}\n\nvoid insert_person()\n{\n    int n;\n    printf(\"Enter how many person you want to insert :\");\n    scanf(\"%d\", &amp;n);\n\n    for (int i = 0; i &lt; n; i++)\n    {\n        person *p1 = (person *)malloc(sizeof(p1));\n        assert(p1 != NULL);\n        printf(\"Enter Person's name : \");\n        scanf(\"%s\", p1-&gt;name);\n        hash_table_insert(p1);\n    }\n    print_table();\n}\n\nvoid find_person()\n{\n    char name[MAX_NAME];\n    printf(\"Enter the name of the person you want to find : \");\n    scanf(\"%s\", name);\n    person *found = hash_table_lookup(name);\n\n    if (found != NULL)\n    {\n        printf(\"Found %s in the hash table \\n\", found-&gt;name);\n    }\n    else\n    {\n        printf(\"Not found in the hash table \\n\");\n    }\n}\n\nvoid delete_person()\n{\n    char name[MAX_NAME];\n    printf(\"Enter the name of the person you want to delete : \");\n    scanf(\"%s\", name);\n    person *found = hash_table_delete(name);\n\n    if (found != NULL)\n    {\n        n_persons--;\n        printf(\"Deleted %s from the hash table \\n\", found-&gt;name);\n    }\n    else\n    {\n        printf(\"Not found in the hash table \\n\");\n    }\n}\n\nvoid hash_to_array()\n{\n    person *temp = NULL;\n    int i = 0, j = 0;\n\n    if (n_persons &lt;= 0)\n    {\n        persons = NULL;\n        return;\n    }\n\n    persons = (person **)realloc(persons, n_persons * sizeof(person *));\n\n    for (i = 0; i &lt; TABLE_SIZE; i++)\n    {\n        if (hash_table[i] == NULL || hash_table[i] == DELETED_NODE)\n            continue;\n\n        persons[j] = hash_table[i];\n        j++;\n\n        temp = hash_table[i]-&gt;next;\n        while (temp != NULL)\n        {\n            persons[j] = temp;\n            j++;\n            temp = temp-&gt;next;\n        }\n    }\n}\n\nvoid sort_persons()\n{\n    int i, j;\n    person *temp;\n\n    hash_to_array();\n\n    if (persons == NULL)\n        return;\n\n    for (i = 0; i &lt; n_persons - 1; i++)\n    {\n        for (j = 0; j &lt; n_persons - i - 1; j++)\n        {\n            if (strcmp(persons[j]-&gt;name, persons[j + 1]-&gt;name) &gt; 0)\n            {\n                temp = persons[j];\n                persons[j] = persons[j + 1];\n                persons[j + 1] = temp;\n            }\n        }\n    }\n}\n\nvoid print_sorted()\n{\n    int i;\n    sort_persons();\n\n    printf(\"Persons [Sorted]:\\n\");\n    for (i = 0; i &lt; n_persons; i++)\n    {\n        printf(\"[%d] %s\\n\", i, persons[i]-&gt;name);\n    }\n}\n\nint main()\n{\n    int choice;\n    printf(\"**************************************************************\\n\");\n    printf(\"*                                                            *\\n\");\n    printf(\"*           HASH TABLE IMPLEMENTATION IN C LANGUAGE          *\\n\");\n    printf(\"*                                                            *\\n\");\n    printf(\"**************************************************************\\n\");\n    printf(\"\\nYour Initial hash table :\\n\");\n    init_hash_table(); // initializes and aasigns all values to 0\n    print_table();     // prints null table\n\n\n    printf(\"\\n\\t:Menu:\\t\\n \\n \ud83d\udd251 : Insert pers \\n \ud83d\udd252 : Delete pers \\n \ud83d\udd253 : Search person \\n \ud83d\udd254 : Print Table \\n \ud83d\udd255 : Print Sorted Table \\n \ud83d\udd256 : Exit\");\n\n    printf(\"\\n\\nEnter Your Choice : \");\n    scanf(\"%d\",&amp;choice);\n\n  do{\n    if(choice == 1)\n        // insert person in hash table\n        insert_person();\n    if(choice == 2)   \n    {// delete person from hash table\n        delete_person();\n        print_table();\n    }\n    if(choice == 3)\n        // find person in hash table\n        find_person();\n    if(choice == 4)\n        // printing the table\n        print_table();\n    if(choice == 5)\n        // printing sorted table\n      print_sorted();\n    if(choice == 6)\n    {    // extit from the loop\n      printf(\"\\n\\t\\tThank You\");\n      break;\n    }\n    printf(\"\\n\\nEnter Your Choice : \");\n    scanf(\"%d\",&amp;choice);\n  }while(choice != 6);\n\n    return 0;\n}\n</code></pre>"},{"location":"Linked-List/Linked-List/","title":"Linked List \ud83d\udd87\ufe0f","text":"<p>A linked list is a linear data structure, in which the elements are not stored at contiguous memory locations. The elements in a linked list are linked using pointers.</p>"},{"location":"Linked-List/Linked-List/#types-of-linked-list","title":"Types of Linked List","text":"<ul> <li>Singly Linked List</li> <li>Doubly Linked List</li> <li>Circular Linked List</li> </ul>"},{"location":"Linked-List/Linked-List/#1-singly-linked-list","title":"1. Singly Linked List  \ud83d\udd17","text":"<p>C program to create a singly linked list.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node\n{\n    int data;\n    struct Node *next;\n};\n\nstruct Node *head;\n\nstruct Node* search(struct Node *head, int x)\n{\n    struct Node *current = head; // Initialize current\n    while (current != NULL)\n    {\n        if (current-&gt;data == x)\n            return current;\n        current = current-&gt;next;\n    }\n    printf(\"\\nElement not found\");\n    return NULL;\n}\n\nstruct Node *searchSorted(struct Node *head, int x)\n{\n    struct Node *current = head; // Initialize current\n    while (current != NULL)\n    {\n        if (current-&gt;data == x)\n            return current;\n\n        else if(current-&gt;data &gt; x)\n        {\n            printf(\"\\nElement not found\");\n            return NULL;\n        }\n        current = current-&gt;next;\n    }\n    printf(\"\\nElement not found\");\n    return NULL;\n}\n\n//count the number of nodes in the linked list\nint count(struct Node *head)\n{\n    struct Node *current = head;\n    int count = 0;\n    while (current != NULL)\n    {\n        count++;\n        current = current-&gt;next;\n    }\n    return count;\n}\n\n//insert a node at the beginning of the linked list\nstruct Node * insertAtBeginning(struct Node *head, int x)\n{\n    struct Node *temp = (struct Node *)malloc(sizeof(struct Node));\n    temp-&gt;data = x;\n    temp-&gt;next = head;\n    head = temp;\n\n    return head;\n}\n\n//insert a node at the end of the linked list\nstruct Node * insertAtEnd(struct Node *head, int x)\n{\n    struct Node *temp = (struct Node *)malloc(sizeof(struct Node));\n    struct Node *current = head;\n    temp-&gt;data = x;\n    temp-&gt;next = NULL;\n\n    if (head == NULL)\n    {\n        head = temp;\n    }\n\n    while (current-&gt;next != NULL)\n    {\n        current = current-&gt;next;\n    }\n    current-&gt;next = temp;\n    return head;\n}\n\n//insert a node at a given position in the linked list\nstruct Node * insertAtPosition(struct Node *head, int x, int pos)\n{\n    struct Node *temp = (struct Node *)malloc(sizeof(struct Node));\n    struct Node *current = head;\n    temp-&gt;data = x;\n    temp-&gt;next = NULL;\n\n    if (pos == 1)\n    {\n        temp-&gt;next = head;\n        head = temp;\n        return head;\n    }\n\n    for (int i = 1; i &lt; pos - 1; i++)\n    {\n        current = current-&gt;next;\n    }\n    temp-&gt;next = current-&gt;next;\n    current-&gt;next = temp;\n    return head;\n}\n\n// insert node after a given node\nstruct Node * insertAfterNode(struct Node *head, int x, int pos)\n{\n    struct Node *temp = (struct Node *)malloc(sizeof(struct Node));\n    struct Node *current = head;\n    temp-&gt;data = x;\n    temp-&gt;next = NULL;\n\n    while (current-&gt;data != pos)\n    {\n        current = current-&gt;next;\n    }\n    temp-&gt;next = current-&gt;next;\n    current-&gt;next = temp;\n    return head;\n}\n\n//delete a node at the beginning of the linked list\nstruct Node * deleteAtBeginning(struct Node *head)\n{\n    struct Node *temp = head;\n    head = head-&gt;next;\n    free(temp);\n    return head;\n}\n\n//delete a node at the end of the linked list\nstruct Node * deleteAtEnd(struct Node *head)\n{\n    struct Node *current = head;\n    struct Node *prev = NULL;\n    while (current-&gt;next != NULL)\n    {\n        prev = current;\n        current = current-&gt;next;\n    }\n    prev-&gt;next = NULL;\n    free(current);\n    return head;\n}\n\n//delete a node at a given position in the linked list\nstruct Node * deleteAtPosition(struct Node *head, int pos)\n{\n    struct Node *current = head;\n    struct Node *prev = NULL;\n    for (int i = 1; i &lt; pos; i++)\n    {\n        prev = current;\n        current = current-&gt;next;\n    }\n    prev-&gt;next = current-&gt;next;\n    free(current);\n    return head;\n}\n\n//delete a node with a given key\nstruct Node * deleteByKey(struct Node *head, int key)\n{\n    struct Node *current = head;\n    struct Node *prev = NULL;\n    while (current-&gt;data != key)\n    {\n        prev = current;\n        current = current-&gt;next;\n    }\n    prev-&gt;next = current-&gt;next;\n    free(current);\n    return head;\n}\n\n// delete before node\nstruct Node * deleteBeforeNode(struct Node *head, int key)\n{\n    struct Node *current = head;\n    struct Node *prev = NULL;\n    struct Node *prev2 = NULL;\n    if(head == NULL)\n    {\n        printf(\"List is empty\");\n        return head;\n    }\n    while (current-&gt;data != key)\n    {\n        prev2 = prev;\n        prev = current;\n        current = current-&gt;next;\n    }\n    prev2-&gt;next = current;\n    free(prev);\n    return head;\n}\n\n// sort the linked list\nstruct Node * sort(struct Node *head)\n{\n    struct Node *current = head;\n    struct Node *index = NULL;\n    int temp;\n\n    if (head == NULL)\n    {\n        return head;\n    }\n    else\n    {\n        while (current-&gt;next != NULL)\n        {\n            index = current-&gt;next;\n\n            while (index != NULL)\n            {\n                if (current-&gt;data &gt; index-&gt;data)\n                {\n                    temp = current-&gt;data;\n                    current-&gt;data = index-&gt;data;\n                    index-&gt;data = temp;\n                }\n                index = index-&gt;next;\n            }\n            current = current-&gt;next;\n        }\n    }\n    return head;\n}\n\nvoid display(struct Node *head)\n{\n    printf(\"\\nYour Linked List is: \");\n    struct Node *current = head;\n    while (current != NULL)\n    {\n        printf(\"%d \", current-&gt;data);\n        current = current-&gt;next;\n    }\n}\n\n// Driver's code\nint main()\n{\n    struct Node *head = NULL;\n    struct Node *tmp = NULL, *last = NULL, *p_next = NULL, *lptr = NULL;\n    int n, temp, swapped;\n    char ch;\n\n    do\n    {\n        tmp = (struct Node *)malloc(sizeof(struct Node));\n\n        printf(\"Enter data: \");\n        scanf(\"%d\", &amp;n);\n\n        for (p_next = head; p_next != NULL; last = p_next, p_next = p_next-&gt;next)\n            ;\n\n        if (last == NULL)\n            head = tmp;\n        else\n            last-&gt;next = tmp;\n\n        tmp-&gt;data = n; // assign data to third node\n        tmp-&gt;next = NULL;\n\n        printf(\"Do you want to enter data again? [y/n] \");\n        scanf(\" %c\", &amp;ch);\n    } while (ch == 'y');\n\n    printf(\"Enter which operation you want to perform:\\n\\n1. Traverse \\n2. Search \\n3. Search in Sorted LinkedList \\n4. Count Nodes \\n5. Insert at Beginning \\n6. Insert at End\\n7. Insert at Position \\n8. Insert after a given node \\n9. Delete at Beginning \\n10. Delete at End \\n11. Delete at Position \\n12. Delete by Key \\n13. Sort \\n14. Exit\\n\");\n    scanf(\"%d\", &amp;temp);\n\n    switch (temp)\n    {\n\n    case 1: \n        printf(\"Traversing the linked list: \");\n        display(head);\n        break;\n\n    case 2:\n        printf(\"Enter the element to be searched: \");\n        scanf(\"%d\", &amp;n);\n        if(search(head, n)!= NULL)\n        printf(\"\\n%d is present in the list\", n);\n        break;\n\n    case 3:\n        printf(\"Enter the element to be searched: \");\n        scanf(\"%d\", &amp;n);\n        if( searchSorted(head, n)!= NULL)\n            printf(\"\\n%d is present in the list\", head-&gt;data);\n        break;\n\n    case 4:\n        printf(\"Number of nodes in the list: %d\", count(head));\n        break;    \n\n    case 5:\n        printf(\"Enter the element to be inserted: \");\n        scanf(\"%d\", &amp;n);\n        head = insertAtBeginning(head, n);\n        display(head);\n        break;\n\n    case 6:\n        printf(\"Enter the element to be inserted: \");\n        scanf(\"%d\", &amp;n);\n        head = insertAtEnd(head, n);\n        display(head);\n        break;\n\n    case 7:\n        printf(\"Enter the element to be inserted: \");\n        scanf(\"%d\", &amp;n);\n        printf(\"Enter the position: \");\n        scanf(\"%d\", &amp;temp);\n        head = insertAtPosition(head, n, temp);\n        display(head);\n        break;\n\n    case 8:\n        printf(\"Enter the element to be inserted: \");\n        scanf(\"%d\", &amp;n);\n        printf(\"Enter the position: \");\n        scanf(\"%d\", &amp;temp);\n        head = insertAfterNode(head, n, temp);\n        display(head);\n        break;\n\n    case 9:\n        head = deleteAtBeginning(head);\n        display(head);\n        break;\n\n    case 10:\n        head = deleteAtEnd(head);\n        display(head);\n        break;\n\n    case 11:\n        printf(\"Enter the position: \");\n        scanf(\"%d\", &amp;temp);\n        head = deleteAtPosition(head, temp);\n        display(head);\n        break;\n\n    case 12:\n        printf(\"Enter the element to be deleted: \");\n        scanf(\"%d\", &amp;n);\n        head = deleteByKey(head, n);\n        display(head);\n        break;\n\n    case 13:\n        head = sort(head);\n\n        break;\n\n    case 14:\n        exit(0);\n        break;\n\n    default:\n        printf(\"Invalid Input\");\n        break;\n    }\n\n    // deallocating memory\n    for (p_next = head; p_next != NULL; p_next = tmp)\n    {\n        tmp = p_next-&gt;next;\n        free(p_next);\n    }\n\n    return 0;\n}\n</code></pre> <pre><code>/* Output\n\nEnter data: 7\nDo you want to enter data again? [y/n] y\nEnter data: 4\nDo you want to enter data again? [y/n] y\nEnter data: 1\nDo you want to enter data again? [y/n] y\nEnter data: 4\nDo you want to enter data again? [y/n] y\nEnter data: 8\nDo you want to enter data again? [y/n] n\nEnter which operation you want to perform:\n\n1. Traverse \n2. Search \n3. Search in Sorted LinkedList \n4. Count Nodes \n5. Insert at Beginning \n6. Insert at End\n7. Insert at Position \n8. Insert after a given node \n9. Delete at Beginning \n10. Delete at End \n11. Delete at Position \n12. Delete by Key \n13. Sort\n14. Exit\n7\n\nEnter the element to be inserted: 5\nEnter the position: 2\nYour LL is: 7 5 4 1 4 8 */\n</code></pre>"},{"location":"Linked-List/Linked-List/#2-circular-linked-list","title":"2. Circular Linked List \ud83d\udd01","text":"<p>Circular Linked List is a variation of Linked List in which the last node points to the first node. This makes the last node act as a sentinel, or a guard. This is useful in situations where there is a need to traverse the list in both directions. For example, in a menu based program, the user can go to the previous menu by going back in the list.</p>"},{"location":"Linked-List/Linked-List/#circular-linked-list-implementation","title":"Circular Linked List Implementation","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct node\n{\n    int data;\n    struct node *next;\n};\n\nstruct node *head = NULL;\n\nvoid traverse()\n{\n    struct node *p_next;\n    if (head == NULL)\n    {\n        printf(\"List is empty\");\n    }\n    else\n    {\n        p_next = head;\n        do\n        {\n            printf(\"%d \", p_next-&gt;data);\n            p_next = p_next-&gt;next;\n        } while (p_next != head);\n    }\n}\n\nvoid insertAtBeginning(int n)\n{\n    struct node *new_node, *p_next;\n    new_node = (struct node *)malloc(sizeof(struct node));\n    new_node-&gt;data = n;\n    if (head == NULL)\n    {\n        head = new_node;\n        new_node-&gt;next = head;\n    }\n    else\n    {\n        p_next = head;\n        while (p_next-&gt;next != head)\n        {\n            p_next = p_next-&gt;next;\n        }\n        p_next-&gt;next = new_node;\n        new_node-&gt;next = head;\n        head = new_node;\n    }\n}\n\nvoid insertAtEnd(int n)\n{\n    struct node *new_node, *p_next;\n    new_node = (struct node *)malloc(sizeof(struct node));\n    new_node-&gt;data = n;\n    if (head == NULL)\n    {\n        head = new_node;\n        new_node-&gt;next = head;\n    }\n    else\n    {\n        p_next = head;\n        while (p_next-&gt;next != head)\n        {\n            p_next = p_next-&gt;next;\n        }\n        p_next-&gt;next = new_node;\n        new_node-&gt;next = head;\n    }\n}\n\nvoid insertAtPosition(int n, int pos)\n{\n    struct node *new_node, *p_next;\n    new_node = (struct node *)malloc(sizeof(struct node));\n    new_node-&gt;data = n;\n    if (head == NULL)\n    {\n        head = new_node;\n        new_node-&gt;next = head;\n    }\n    else\n    {\n        p_next = head;\n        for (int i = 1; i &lt; pos - 1; i++)\n        {\n            p_next = p_next-&gt;next;\n        }\n        new_node-&gt;next = p_next-&gt;next;\n        p_next-&gt;next = new_node;\n    }\n}\n\nvoid insertAfterNode(int n, int key)\n{\n    struct node *new_node, *p_next;\n    new_node = (struct node *)malloc(sizeof(struct node));\n    new_node-&gt;data = n;\n    if (head == NULL)\n    {\n        head = new_node;\n        new_node-&gt;next = head;\n    }\n    else\n    {\n        p_next = head;\n        do\n        {\n            if (p_next-&gt;data == key)\n            {\n                new_node-&gt;next = p_next-&gt;next;\n                p_next-&gt;next = new_node;\n                if (p_next == head)\n                {\n                    head = new_node;\n                }\n                break;\n            }\n            p_next = p_next-&gt;next;\n        } while (p_next != head);\n    }\n}\n\nvoid deleteAtBeginning()\n{\n    struct node *p_next;\n    if (head == NULL)\n    {\n        printf(\"List is empty\");\n    }\n    else\n    {\n        p_next = head;\n        while (p_next-&gt;next != head)\n        {\n            p_next = p_next-&gt;next;\n        }\n        p_next-&gt;next = head-&gt;next;\n        free(head);\n        head = p_next-&gt;next;\n    }\n}\n\nvoid deleteAtEnd()\n{\n    struct node *p_next, *tmp;\n    if (head == NULL)\n    {\n        printf(\"List is empty\");\n    }\n    else\n    {\n        p_next = head;\n        while (p_next-&gt;next != head)\n        {\n            tmp = p_next;\n            p_next = p_next-&gt;next;\n        }\n        tmp-&gt;next = head;\n        free(p_next);\n    }\n}\n\nvoid deleteAtPosition(int pos)\n{\n    struct node *p_next, *tmp;\n    if (head == NULL)\n    {\n        printf(\"List is empty\");\n    }\n    else\n    {\n        p_next = head;\n        for (int i = 1; i &lt; pos; i++)\n        {\n            tmp = p_next;\n            p_next = p_next-&gt;next;\n        }\n        tmp-&gt;next = p_next-&gt;next;\n        free(p_next);\n    }\n}\n\nvoid deleteByKey(int key)\n{\n    struct node *p_next, *tmp;\n    if (head == NULL)\n    {\n        printf(\"List is empty\");\n    }\n    else\n    {\n        p_next = head;\n        do\n        {\n            if (p_next-&gt;data == key)\n            {\n                tmp-&gt;next = p_next-&gt;next;\n                free(p_next);\n                break;\n            }\n            tmp = p_next;\n            p_next = p_next-&gt;next;\n        } while (p_next != head);\n    }\n}\n\nint main()\n{\n    int choice, n, pos, key;\n    do\n    {\n        printf(\"\\n1. Traverse\\n2. Insert at Beginning\\n3. Insert at End\\n4. Insert at Position\\n5. Insert after a given node\\n6. Delete at Beginning\\n7. Delete at End\\n8. Delete at Position\\n9. Delete by Key\\n10. Exit\\n\");\n        scanf(\"%d\", &amp;choice);\n        switch (choice)\n        {\n        case 1:\n            traverse();\n            break;\n        case 2:\n            printf(\"\\nEnter the element to be inserted: \");\n            scanf(\"%d\", &amp;n);\n            insertAtBeginning(n);\n            break;\n        case 3:\n            printf(\"\\nEnter the element to be inserted: \");\n            scanf(\"%d\", &amp;n);\n            insertAtEnd(n);\n            break;\n        case 4:\n            printf(\"\\nEnter the element to be inserted: \");\n            scanf(\"%d\", &amp;n);\n            printf(\"Enter the position: \");\n            scanf(\"%d\", &amp;pos);\n            insertAtPosition(n, pos);\n            break;\n        case 5:\n            printf(\"\\nEnter the element to be inserted: \");\n            scanf(\"%d\", &amp;n);\n            printf(\"Enter the key: \");\n            scanf(\"%d\", &amp;key);\n            insertAfterNode(n, key);\n            break;\n        case 6:\n            deleteAtBeginning();\n            break;\n        case 7:\n            deleteAtEnd();\n            break;\n        case 8:\n            printf(\"\\nEnter the position: \");\n            scanf(\"%d\", &amp;pos);\n            deleteAtPosition(pos);\n            break;\n        case 9:\n            printf(\"\\nEnter the key: \");\n            scanf(\"%d\", &amp;key);\n            deleteByKey(key);\n            break;\n        case 10:\n            exit(0);\n        default:\n            printf(\"\\nInvalid choice\");\n        }\n    } while (choice != 10);\n    return 0;\n}\n</code></pre> <pre><code> Output:\n\n    1. Traverse\n    2. Insert at Beginning\n    3. Insert at End\n    4. Insert at Position\n    5. Insert after a given node\n    6. Delete at Beginning\n    7. Delete at End\n    8. Delete at Position\n    9. Delete by Key\n    10. Exit\n\n    1\n    List is empty\n\n    1. Traverse\n    2. Insert at Beginning\n    3. Insert at End\n    4. Insert at Position\n    5. Insert after a given node\n    6. Delete at Beginning\n    7. Delete at End\n    8. Delete at Position\n    9. Delete by Key\n    10. Exit\n\n    2\n    Enter the element to be inserted: 1\n\n    1. Traverse\n    2. Insert at Beginning\n    3. Insert at End\n    4. Insert at Position\n    5. Insert after a given node\n    6. Delete at Beginning\n    7. Delete at End\n    8. Delete at Position\n    9. Delete by Key\n    10. Exit\n\n    2\n    Enter the element to be inserted: 2\n    2 1\n\n    1. Traverse\n    2. Insert at Beginning\n    3. Insert at End\n    4. Insert at Position\n    5. Insert after a given node\n    6. Delete at Beginning\n    7. Delete at End\n    8. Delete at Position\n    9. Delete by Key\n    10. Exit\n\n    3\n    Enter the element to be inserted: 3\n    2 1 3\n</code></pre>"},{"location":"Linked-List/Linked-List/#doubly-linked-list","title":"Doubly Linked List","text":"<p>A doubly linked list is a linked data structure that consists of a set of sequentially linked records called nodes. Each node contains two fields, called links, that are references to the previous and to the next node in the sequence of nodes. The beginning and ending nodes' previous and next links, respectively, point to some kind of terminator, typically a sentinel node or null, to facilitate traversal of the list. If there is only one sentinel node, then the list is circularly linked via the sentinel node. It can be conceptualized as two singly linked lists formed from the same data items, but in opposite sequential orders.</p>"},{"location":"Linked-List/Linked-List/#insertion","title":"Insertion","text":"<pre><code>void insertAtBeginning(int n)\n{\n    struct node *new_node;\n    new_node = (struct node *)malloc(sizeof(struct node));\n    new_node-&gt;data = n;\n    if (head == NULL)\n    {\n        head = new_node;\n        new_node-&gt;next = NULL;\n        new_node-&gt;prev = NULL;\n    }\n    else\n    {\n        new_node-&gt;next = head;\n        new_node-&gt;prev = NULL;\n        head-&gt;prev = new_node;\n        head = new_node;\n    }\n}\n\nvoid insertAtEnd(int n)\n{\n    struct node *new_node, *p_next;\n    new_node = (struct node *)malloc(sizeof(struct node));\n    new_node-&gt;data = n;\n    if (head == NULL)\n    {\n        head = new_node;\n        new_node-&gt;next = NULL;\n        new_node-&gt;prev = NULL;\n    }\n    else\n    {\n        p_next = head;\n        while (p_next-&gt;next != NULL)\n        {\n            p_next = p_next-&gt;next;\n        }\n        p_next-&gt;next = new_node;\n        new_node-&gt;next = NULL;\n        new_node-&gt;prev = p_next;\n    }\n}\n\nvoid insertAtPosition(int n, int pos)\n{\n    struct node *new_node, *p_next, *tmp;\n    new_node = (struct node *)malloc(sizeof(struct node));\n    new_node-&gt;data = n;\n    if (head == NULL)\n    {\n        head = new_node;\n        new_node-&gt;next = NULL;\n        new_node-&gt;prev = NULL;\n    }\n    else\n    {\n        p_next = head;\n        for (int i = 1; i &lt; pos; i++)\n        {\n            tmp = p_next;\n            p_next = p_next-&gt;next;\n        }\n        tmp-&gt;next = new_node;\n        new_node-&gt;next = p_next;\n        new_node-&gt;prev = tmp;\n        p_next-&gt;prev = new_node;\n    }\n}\n\nvoid insertAfterNode(int n, int key)\n{\n    struct node *new_node, *p_next;\n    new_node = (struct node *)malloc(sizeof(struct node));\n    new_node-&gt;data = n;\n    if (head == NULL)\n    {\n        head = new_node;\n        new_node-&gt;next = NULL;\n        new_node-&gt;prev = NULL;\n    }\n    else\n    {\n        p_next = head;\n        while (p_next-&gt;data != key)\n        {\n            p_next = p_next-&gt;next;\n        }\n        new_node-&gt;next = p_next-&gt;next;\n        new_node-&gt;prev = p_next;\n        p_next-&gt;next = new_node;\n        new_node-&gt;next-&gt;prev = new_node;\n    }\n}\n</code></pre>"},{"location":"Mini_Projects/Sudoku/","title":"Sudoku","text":""},{"location":"Mini_Projects/Sudoku/#sudoku-using-backtracking","title":"Sudoku Using Backtracking \ud83e\udde9","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint isAvailable(int puzzle[][9], int row, int col, int num)\n{\n    int rowStart = (row/3) * 3;\n    int colStart = (col/3) * 3;\n    int i, j;\n\n    for(i=0; i&lt;9; ++i)\n    {\n        if (puzzle[row][i] == num) \n            return 0;\n        if (puzzle[i][col] == num)\n            return 0;\n\n        if (puzzle[rowStart + (i%3)][colStart + (i/3)] == num) \n            return 0;\n    }\n    return 1;\n}\n\nint fillSudoku(int puzzle[][9], int row, int col)\n{\n    int i;\n    if(row&lt;9 &amp;&amp; col&lt;9)\n    {\n        if(puzzle[row][col] != 0)\n        {\n            if((col+1)&lt;9) \n                return fillSudoku(puzzle, row, col+1);\n            else if((row+1)&lt;9) \n                return fillSudoku(puzzle, row+1, 0);\n            else \n                return 1;\n        }\n        else\n        {\n            for(i=0; i&lt;9; ++i)\n            {\n                if(isAvailable(puzzle, row, col, i+1))\n                {\n                    puzzle[row][col] = i+1;\n                    if((col+1)&lt;9)\n                    {\n                        if(fillSudoku(puzzle, row, col +1)) \n                            return 1;\n                        else \n                            puzzle[row][col] = 0;\n                    }\n                    else if((row+1)&lt;9)\n                    {\n                        if(fillSudoku(puzzle, row+1, 0))\n                             return 1;\n                        else\n                             puzzle[row][col] = 0;\n                    }\n                    else \n                        return 1;\n                }\n            }\n        }\n        return 0;\n    }\n    else \n        return 1;\n}\n\nint main()\n{\n    int i, j;\n    int puzzle[9][9]={{0, 0, 0, 0, 0, 0, 0, 9, 0},\n                      {1, 9, 0, 4, 7, 0, 6, 0, 8},\n                      {0, 5, 2, 8, 1, 9, 4, 0, 7},\n                      {2, 0, 0, 0, 4, 8, 0, 0, 0},\n                      {0, 0, 9, 0, 0, 0, 5, 0, 0},\n                      {0, 0, 0, 7, 5, 0, 0, 0, 9},\n                      {9, 0, 7, 3, 6, 4, 1, 8, 0},\n                      {5, 0, 6, 0, 8, 1, 0, 7, 4},\n                      {0, 8, 0, 0, 0, 0, 0, 0, 0}};\n\n    if(fillSudoku(puzzle, 0, 0))\n    {\n        printf(\"\\n +-----------+-----------+-----------+\\n\");\n        for(i=1; i&lt;10; ++i)\n        {\n            for(j=1; j&lt;10; ++j) \n                printf(\" | %d\", puzzle[i-1][j-1]);\n                printf(\" |\\n\");\n            if (i%3 == 0) \n                printf(\" +-----------+-----------+-----------+\\n\");\n        }\n    }\n    else \n        printf(\"\\n\\nNO SOLUTION\\n\\n\");\n\n    return 0;\n}\n</code></pre>"},{"location":"Mini_Projects/Sudoku/#output","title":"Output","text":"<pre><code>    +-----------+-----------+-----------+\n    | 3 | 6 | 4 | 1 | 2 | 5 | 7 | 9 | 8 |\n    | 1 | 9 | 8 | 4 | 7 | 3 | 6 | 5 | 2 |\n    | 7 | 5 | 2 | 8 | 1 | 9 | 4 | 3 | 6 |\n    +-----------+-----------+-----------+\n    | 2 | 3 | 1 | 6 | 4 | 8 | 9 | 7 | 5 |\n    | 4 | 7 | 9 | 2 | 3 | 5 | 8 | 6 | 1 |\n    | 8 | 4 | 5 | 7 | 5 | 6 | 2 | 1 | 9 |\n    +-----------+-----------+-----------+\n    | 9 | 2 | 7 | 3 | 6 | 4 | 1 | 8 | 5 |\n    | 5 | 1 | 6 | 9 | 8 | 1 | 3 | 7 | 4 |\n    | 4 | 8 | 3 | 5 | 9 | 7 | 2 | 1 | 6 |\n    +-----------+-----------+-----------+\n</code></pre>"},{"location":"Queue/queue/","title":"Queue \ud83e\uddcd\u200d\u2642\ufe0f\ud83e\uddcd\u200d\u2640\ufe0f\ud83e\uddcd\u200d\u2642\ufe0f\ud83e\uddcd\u200d\u2640\ufe0f\ud83e\uddcd\u200d\u2640\ufe0f\ud83e\uddcd\u200d\u2642\ufe0f","text":""},{"location":"Queue/queue/#introduction","title":"Introduction","text":"<p>Queue is a data structure that follows the FIFO (First In First Out) principle. It is a linear data structure that stores items in a sequential manner. The addition of new elements in a queue is at the rear end and the removal of existing elements takes place from the front end of the queue.</p>"},{"location":"Queue/queue/#basic-operations","title":"Basic Operations","text":"<ul> <li>Enqueue: Adds an item to the queue. If the queue is full, then it is said to be an Overflow condition.</li> <li>Dequeue: Removes an item from the queue. The items are popped in the same order in which they are pushed. If the queue is empty, then it is said to be an Underflow condition.</li> </ul>"},{"location":"Queue/queue/#applications","title":"Applications","text":"<ul> <li>CPU Scheduling</li> <li>Disk Scheduling</li> <li>Handling of interrupts in real-time systems</li> <li>Call Center phone systems use Queues to hold people calling them in an order, until a service representative is free.</li> </ul>"},{"location":"Queue/queue/#implementation","title":"Implementation","text":""},{"location":"Queue/queue/#array-implementation","title":"Array Implementation","text":"C <pre><code>// Program for queue operations using array\n\n    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n\n    #define MAX 5 //size of queue\n\n    int queue[MAX];\n\n    int front = -1;\n\n    int rear = -1;\n\n    void insert()\n\n    {\n\n        int item;\n\n    if (front == 0 &amp;&amp; rear == MAX - 1)\n\n        printf(\"\\n Queue Overflow \"); // Overflow\n\n    else\n    {\n        if (front == -1 &amp;&amp; rear == -1)\n        {\n            printf(\"Queue is empty, Inserting first element\");\n            front = front+1;\n            rear = rear+1;\n        }\n        else if(rear == MAX-1)\n        {\n            rear = 0;\n        }\n        else\n        {\n            rear = rear+1;\n        }\n\n\n        printf(\"\\n Input the element for insertion in queue : \"); // Insertion\n\n        scanf(\"%d\", &amp;item);\n\n        queue[rear] = item;\n        }\n\n    }\n\n    void remove()\n    {\n    if (front == -1 || rear == -1)\n    {\n    printf(\"\\n Queue Underflow \"); // Underflow\n    return;\n    }\n    else if(front == rear)\n    {\n    printf(\"\\n Deleted element is %d\", queue[front]);\n    front = -1;\n    rear = -1;\n    }\n    else if(front == MAX-1)\n    {\n    printf(\"\\n Deleted element is %d\", queue[front]);\n    front = 0;\n    }\n    else\n    {\n    printf(\"\\n Deleted element is %d\", queue[front]);\n    front = front+1;\n    }\n    }\n\n    void display()\n    {\n    int i;\n    if (front == -1 &amp;&amp; rear == -1)\n    {\n    printf(\"\\n Queue is empty \");\n    }\n    else\n    {\n    printf(\"\\n Queue is : \");\n    if(front &lt;= rear)\n    {\n    for (i = front; i &lt;= rear; i++)\n    {\n    printf(\"%d \", queue[i]);\n    }\n    }\n    else\n    {\n    for(i=front;i&lt;MAX;i++)\n    {\n    printf(\"%d \",queue[i]);\n    }\n    for(i=0;i&lt;=rear;i++)\n    {\n    printf(\"%d \",queue[i]);\n    }\n    }\n    }\n    }\n\n    int main()\n    {\n    int choice;\n    while (1)\n    {\n    printf(\"\\n1. Insert element to queue \"); // Insertion\n    printf(\"\\n2. Delete element from queue \"); // Deletion\n    printf(\"\\n3. Display all elements of queue \"); // Display\n    printf(\"\\n4. Quit \"); // Exit\n    printf(\"\\nEnter your choice : \"); // Choice\n    scanf(\"%d\", &amp;choice);\n\n        switch (choice)\n        {\n        case 1:\n            insert();\n            break;\n\n        case 2:\n            remove();\n            break;\n\n        case 3:\n            display();\n            break;\n\n        case 4:\n            exit(1);\n\n        default:\n            printf(\"\\nWrong choice \"); // Wrong choice\n            break;\n        }\n    }\n    return 0;\n\n    } // End of main\n</code></pre> <pre><code>     OUTPUT\n\n\n1. Insert element to queue\n2. Delete element from queue\n3. Display all elements of queue\n4. Quit\n   Enter your choice : 1\n\nInput the element for insertion in queue : 4\n\n1. Insert element to queue\n2. Delete element from queue\n3. Display all elements of queue\n4. Quit\n   Enter your choice : 1\n\nInput the element for insertion in queue : 9\n\n1. Insert element to queue\n2. Delete element from queue\n3. Display all elements of queue\n4. Quit\n   Enter your choice : 1\n\nInput the element for insertion in queue : 4\n\n1. Insert element to queue\n2. Delete element from queue\n3. Display all elements of queue\n4. Quit\n   Enter your choice : 3\n\nQueue is : 4 9 4\n\n1. Insert element to queue\n2. Delete element from queue\n3. Display all elements of queue\n4. Quit\n   Enter your choice : 1\n\nInput the element for insertion in queue : 7\n\n1. Insert element to queue\n2. Delete element from queue\n3. Display all elements of queue\n4. Quit\n   Enter your choice : 1\n\nInput the element for insertion in queue : 5\n\n1.  Insert element to queue\n2.  Delete element from queue\n3.  Display all elements of queue\n4.  Quit\n    Enter your choice : 1\n\n        Input the element for insertion in queue : 6\n\n        Queue Overflow\n\n5.  Insert element to queue\n6.  Delete element from queue\n7.  Display all elements of queue\n8.  Quit\n    Enter your choice : 2\n\nDeleted element is 4\n\n1. Insert element to queue\n2. Delete element from queue\n3. Display all elements of queue\n4. Quit\n   Enter your choice : 3\n\nQueue is : 9 4 7 5\n\n1. Insert element to queue\n2. Delete element from queue\n3. Display all elements of queue\n4. Quit\n   Enter your choice : 2\n\nDeleted element is 9\n\n1. Insert element to queue\n2. Delete element from queue\n3. Display all elements of queue\n4. Quit\n   Enter your choice : 2\n\nDeleted element is 4\n\n1. Insert element to queue\n2. Delete element from queue\n3. Display all elements of queue\n4. Quit\n   Enter your choice : 2\n\nDeleted element is 7\n\n1. Insert element to queue\n2. Delete element from queue\n3. Display all elements of queue\n4. Quit\n   Enter your choice : 2\n\nDeleted element is 5\n\n1. Insert element to queue\n2. Delete element from queue\n3. Display all elements of queue\n4. Quit\n   Enter your choice : 2\n\nQueue Underflow\n\n1. Insert element to queue\n2. Delete element from queue\n3. Display all elements of queue\n4. Quit\n   Enter your choice : 3\n\nQueue is empty\n\n1. Insert element to queue\n2. Delete element from queue\n3. Display all elements of queue\n4. Quit\n   Enter your choice : 4\n</code></pre>"},{"location":"Queue/queue/#linked-list-implementation","title":"Linked List Implementation","text":"C <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node\n{\n    int data;\n    struct Node *next;\n} *front = NULL, *rear = NULL;\n\nvoid enqueue(int data)\n{\n    struct Node *t;\n    t = (struct Node *)malloc(sizeof(struct Node));\n    if (t == NULL)\n    {\n        printf(\"Queue is full\\n\");\n    }\n    else\n    {\n        t-&gt;data = data;\n        t-&gt;next = NULL;\n        if (front == NULL)\n        {\n            front = rear = t;\n        }\n        else\n        {\n            rear-&gt;next = t;\n            rear = t;\n        }\n    }\n}\n\nint dequeue()\n{\n    int x = -1;\n    struct Node *t;\n    if (front == NULL)\n    {\n        printf(\"Queue is empty\\n\");\n    }\n    else\n    {\n        x = front-&gt;data;\n        t = front;\n        front = front-&gt;next;\n        free(t);\n    }\n    return x;\n}\n\nvoid display()\n{\n    struct Node *p = front;\n    while (p)\n    {\n        printf(\"%d \", p-&gt;data);\n        p = p-&gt;next;\n    }\n    printf(\"\\n\");\n}\n\nint main()\n{\n    enqueue(1);\n    enqueue(2);\n    enqueue(3);\n    enqueue(4);\n    enqueue(5);\n    enqueue(6);\n    display();\n    dequeue();\n    dequeue();\n    display();\n    enqueue(6);\n    enqueue(7);\n    display();\n    return 0;\n}\n</code></pre>"},{"location":"Queue/queue/#time-complexity","title":"Time Complexity","text":"Operation Time Complexity Insertion O(1) Deletion O(1) Search O(n) Access O(n)"},{"location":"Queue/queue/#problems","title":"Problems","text":"<ul> <li>Leetcode - 232. Implement Queue using Stacks</li> <li>Leetcode - 622. Design Circular Queue</li> <li>Leetcode - 933. Number of Recent Calls</li> <li>Leetcode - 346. Moving Average from Data Stream</li> <li>Leetcode - 225. Implement Stack using Queues</li> </ul>"},{"location":"Searching/searching/","title":"Searching in One dimention array","text":"<p>This algorithm is used to search an element in a one dimention array.</p> CC++Python <pre><code>    #include &lt;stdio.h&gt;\n    int main()\n    {\n        int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        int i, n, flag = 0;\n        printf(\"Enter the number to be searched: \");\n        scanf(\"%d\", &amp;n);\n        for (i = 0; i &lt; 10; i++)\n        {\n            if (arr[i] == n)\n            {\n                flag = 1;\n                break;\n            }\n        }\n        if (flag == 1)\n        {\n            printf(\"The number is found at position %d\", i + 1);\n        }\n        else\n        {\n            printf(\"The number is not found\");\n        }\n        return 0;\n    }\n</code></pre> <pre><code>    #include &lt;stdio.h&gt;\n    int main()\n    {\n        int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        int i, n, flag = 0;\n        cout&lt;&lt;\"Enter the number to be searched: \";\n        cin&gt;&gt;n;\n        for (i = 0; i &lt; 10; i++)\n        {\n            if (arr[i] == n)\n            {\n                flag = 1;\n                break;\n            }\n        }\n        if (flag == 1)\n        {\n            cout&lt;&lt;\"The number is found at position &lt;&lt;   i + 1\";\n        }\n        else\n        {\n            cout&lt;&lt;\"The number is not found\";\n        }\n        return 0;\n    }\n</code></pre> <pre><code>    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    n = int(input(\"Enter the number to be searched: \"))\n    flag = 0\n    for i in range(10):\n        if arr[i] == n:\n            flag = 1\n            break\n    if flag == 1:\n        print(\"The number is found at position \", i + 1)\n    else:\n        print(\"The number is not found\")\n</code></pre>"},{"location":"Searching/searching/#output","title":"Output","text":"<pre><code>Enter the number to be searched: 5\nThe number is found at position 5\n</code></pre>"},{"location":"Searching/searching/#time-complexity","title":"Time Complexity","text":"<p>The time complexity of this algorithm is O(n).</p>"},{"location":"Sorting/sorting/","title":"Sorting techniques of arrays","text":""},{"location":"Sorting/sorting/#bubble-sort","title":"Bubble sort","text":"<p>Bubble sort is a simple sorting algorithm. This sorting algorithm is comparison-based algorithm in which each pair of adjacent elements is compared and the elements are swapped if they are not in order. This algorithm is not suitable for large data sets as its average and worst case complexity are of \u039f(n2) where n is the number of items.</p>"},{"location":"Sorting/sorting/#pseudocode","title":"Pseudocode","text":"<pre><code>procedure bubbleSort( A : list of sortable items )\n    n = length(A)\n    repeat\n        swapped = false\n        for i = 1 to n-1 inclusive do\n            /* if this pair is out of order */\n            if A[i-1] &gt; A[i] then\n                /* swap them and remember something changed */\n                swap( A[i-1], A[i] )\n                swapped = true\n            end if\n        end for\n    until not swapped\nend procedure\n</code></pre>"},{"location":"Sorting/sorting/#flowchart","title":"FLowchart","text":"CC++Python <pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int arr[10], i, j, temp;\n    printf(\"Enter the elements of the array: \");\n    for (i = 0; i &lt; 10; i++)\n    {\n        scanf(\"%d\", &amp;arr[i]);\n    }\n    for (i = 0; i &lt; 10; i++)\n    {\n        for (j = i + 1; j &lt; 10; j++)\n        {\n            if (arr[i] &gt; arr[j])\n            {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    printf(\"The sorted array is: \");\n    for (i = 0; i &lt; 10; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    int arr[10], i, j, temp;\n    cout&lt;&lt;\"Enter the elements of the array: \";\n    for (i = 0; i &lt; 10; i++)\n    {\n        cin&gt;&gt;arr[i];\n    }\n    for (i = 0; i &lt; 10; i++)\n    {\n        for (j = i + 1; j &lt; 10; j++)\n        {\n            if (arr[i] &gt; arr[j])\n            {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    cout&lt;&lt;\"The sorted array is: \";\n    for (i = 0; i &lt; 10; i++)\n    {\n        cout&lt;&lt;arr[i]&lt;&lt;\" \";\n    }\n    return 0;\n}\n</code></pre> <pre><code>arr = []\nprint(\"Enter the elements of the array: \")\nfor i in range(10):\n    arr.append(int(input()))\nfor i in range(10):\n    for j in range(i + 1, 10):\n        if arr[i] &gt; arr[j]:\n            temp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = temp\nprint(\"The sorted array is: \")\nfor i in range(10):\n    print(arr[i], end=\" \")\n</code></pre>"},{"location":"Sorting/sorting/#selection-sort","title":"Selection sort","text":"<p>Selection sort is a simple sorting algorithm. This sorting algorithm is an in-place comparison-based algorithm in which the list is divided into two parts, the sorted part at the left end and the unsorted part at the right end. Initially, the sorted part is empty and the unsorted part is the entire list.</p>"},{"location":"Sorting/sorting/#pseudocode_1","title":"Pseudocode","text":"<pre><code>procedure selectionSort( A : list of sortable items )\n    n = length(A)\n    for i = 1 to n-1 inclusive do\n        /* set current element as minimum*/\n        min = i    \n        /* check the element to be minimum */         \n        for j = i+1 to n inclusive do\n            if A[j] &lt; A[min] then\n                min = j;\n            end if\n        end for\n        /* swap the minimum element with the current element*/  \n        if indexMin != i  then\n            swap A[min] and A[i]\n        end if\n    end for\nend procedure\n</code></pre>"},{"location":"Sorting/sorting/#flowchart_1","title":"FLowchart","text":"C <pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n        int main()\n        {\n            int *a, n, i, j, current, temp;\n            printf(\"Enter number of elements :\");\n            scanf(\"%d\", &amp;n);\n\n            a = (int *)malloc(n * sizeof(int));\n\n            printf(\"Enter %d Numbers : \", n);\n            for (i = 0; i &lt; n; i++)\n                scanf(\"%d\", &amp;a[i]);\n\n            for(i = 0; i &lt; n - 1; i++)\n            {\n                int min_idx= i;\n                for(j = i + 1; j &lt; n; j++)\n                {\n                    if(a[j] &lt; a[min_idx])\n                        temp = a[j];\n                        a[j] = a[min_idx];\n                        a[min_idx] = temp;\n                }\n\n            }\n            printf(\"Sorted Array:n\");\n            for(i = 0; i &lt; n; i++)\n                printf(\"%dn\", a[i]);\n            return 0;\n        }\n</code></pre> C++"},{"location":"Sorting/sorting/#include-iostream-using-namespace-std-int-main-int-a100-n-i-j-position-swap-coutenter-number-of-elementsn-cinn-coutenter-n-numbersn-for-i-0-i-n-i-cinai-fori-0-i-n-1-i-positioni-forj-i-1-j-n-j-ifaposition-aj-positionj-ifposition-i-swapai-aiaposition-apositionswap-coutsorted-arrayn-fori-0-i-n-i-coutain-return-0","title":"<pre><code>        #include &lt;iostream&gt;\n        using namespace std;\n        int main()\n        {\n            int a[100], n, i, j, position, swap;\n            cout&lt;&lt;\"Enter number of elementsn\";\n            cin&gt;&gt;n;\n            cout&lt;&lt;\"Enter \"&lt;&lt;n&lt;&lt;\" Numbersn\";\n            for (i = 0; i &lt; n; i++)\n                cin&gt;&gt;a[i];\n            for(i = 0; i &lt; n - 1; i++)\n            {\n                position=i;\n                for(j = i + 1; j &lt; n; j++)\n                {\n                    if(a[position] &gt; a[j])\n                    position=j;\n                }\n                if(position != i)\n                {\n                    swap=a[i];\n                    a[i]=a[position];\n                    a[position]=swap;\n                }\n            }\n            cout&lt;&lt;\"Sorted Array:n\";\n            for(i = 0; i &lt; n; i++)\n                cout&lt;&lt;a[i]&lt;&lt;\"n\";\n            return 0;\n        }\n</code></pre>","text":""},{"location":"Sorting/sorting/#insertion-sort","title":"Insertion sort","text":"<p>Insertion sort is a simple sorting algorithm that works the way we sort playing cards in our hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed at the correct position in the sorted part.</p>"},{"location":"Sorting/sorting/#pseudocode_2","title":"Pseudocode","text":"<pre><code>procedure insertionSort( A : list of sortable items )\n    n = length(A)\n    for i = 1 to n-1 inclusive do\n        /* select value to be inserted */\n        value = A[i]\n        /* select hole position where number is to be inserted */\n        hole = i\n        /*locate hole position for the element to be inserted */\n        while hole &gt; 0 and A[hole-1] &gt; value do\n            A[hole] = A[hole-1]\n            hole = hole -1\n        end while\n        /* insert the number at hole position */\n        A[hole] = value\n    end for\nend procedure\n</code></pre>"},{"location":"Sorting/sorting/#flowchart_2","title":"Flowchart","text":"C <p>```c</p>"},{"location":"Sorting/sorting/#include","title":"include","text":""},{"location":"Sorting/sorting/#include_1","title":"include    <p>int main(){         int *arr, i, j,size,current, temp;         printf(\"Enter the size of the array: \");         scanf(\"%d\",&amp;size);</p> <pre><code>    arr = (int*)malloc(size*sizeof(int));\n\n    printf(\"Enter %d elements:\",size);\n    for (i = 0; i &lt; size; i++)\n    {\n        scanf(\"%d\", &amp;arr[i]);\n    }\n\n    //logic\n    for ( i = 0; i &lt; size; i++)\n    {\n        current = arr[i];\n        j=i-1;\n        while(j&gt;=0 &amp;&amp; arr[j]&gt;current)\n        {\n            arr[j+1]=arr[j];\n            j--;\n        }\n        arr[j+1]=current;\n    }\n\n     printf(\"The sorted array is: \");\n    for (i = 0; i &lt; size; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n</code></pre> <p>return 0; }     ```</p> C++   <p>```c++</p>","text":""},{"location":"Sorting/sorting/#include_2","title":"include  <p>using namespace std;</p> <p>int main(){     int *arr, i, j,size,current, temp;     printf(\"Enter the size of the array: \");     scanf(\"%d\",&amp;size);</p> <pre><code>arr = (int*)malloc(size*sizeof(int));\n\nprintf(\"Enter %d elements:\",size);\nfor (i = 0; i &lt; size; i++)\n{\n    cin&gt;&gt;arr[i];\n}\n\n//logic\nfor ( i = 1; i &lt; size; i++)\n{\n    current = arr[i];\n    j=i-1;\n    while(j&gt;=0 &amp;&amp; arr[j]&gt;current)\n    {\n        arr[j+1]=arr[j];\n        j--;\n    }\n    arr[j+1]=current;\n}\n\n printf(\"The sorted array is: \");\nfor (i = 0; i &lt; size; i++)\n{\n    cout &lt;&lt; arr[i]);\n}\n</code></pre>    <p>return 0; }     ```</p>","text":""},{"location":"Sorting/sorting/#radix-sort","title":"Radix sort","text":"<p>Radix sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by the individual digits which share the same significant position and value. A positional notation is required, but because integers can represent strings of characters (e.g., names or dates) and specially formatted floating point numbers, radix sort is not limited to integers.</p>"},{"location":"Sorting/sorting/#pseudocode_3","title":"Pseudocode","text":"<pre><code>procedure radixsort( list )\n   bucket = new array of buckets\n   for i = 0 to length(list) - 1\n      insert list[i] into bucket[0]\n   end for\n   for i = 0 to 9\n      sort bucket[i] using any sorting algorithm\n      (recursive radix sort can be used here)\n   end for\n   concatenate the buckets\nend procedure\n</code></pre>"},{"location":"Sorting/sorting/#flowchart_3","title":"Flowchart","text":"CC++Python <pre><code>#include&lt;stdio.h&gt;\n\nint Getmax(int arr[],int size){\n    int max=arr[0];\n    for (int i = 1; i &lt; size; i++)\n    {\n        if (arr[i]&gt;max)\n        {\n            max=arr[i];\n        }\n\n    }\n    return max;\n}\n\nvoid CountingSort(int arr[],int size,int div){\n    int output[size];\n    int count[10]={0};\n\n    for (int i = 0; i &lt; size; i++)\n    {\n        count[(arr[i]/div)%10]++;\n    }\n    for (int i = 1; i &lt; 10; i++)\n    {\n        count[i]+=count[i-1];\n    }\n    for (int i = size-1; i &gt;= 0; i--)\n    {\n        output[count[(arr[i]/div)%10 ]-1]=arr[i];\n        count[(arr[i]/div)%10]--;\n    }\n    for (int i = 0; i &lt; size; i++)\n    {\n        arr[i]=output[i];\n    }\n\n}\n\nvoid radixSort(int arr[],int size){\n    int m = Getmax(arr,size);\n\n    for (int div= 1; m/div &gt;0; div*=10)\n    {\n        CountingSort(arr,size,div);\n    }\n\n}\n\nint main(){\nint size;\nprintf(\"Enter size of array: )\";\nscanf(\"%d\",&amp;size);\n\nint arr[size];\nprintf(\"Enter %d integers in any order : \",size);\n\nfor(int i=0;i&lt;size;i++){\n    scanf(\"%d\",&amp;arr[i]);\n}\n\nfor(int i=0;i&lt;size;i++){\n    printf(\"%d \",arr[i]);\n}\n\n    printf(\"\\n\");\n    radixSort(arr,size);\n\nfor(int i=0;i&lt;size;i++){\n    printf(\"%d\",arr[i]);\n}\n    return 0;\n}\n</code></pre> <pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nint Getmax(int arr[],int size){\n    int max=arr[0];\n    for (int i = 1; i &lt; size; i++)\n    {\n        if (arr[i]&gt;max)\n        {\n            max=arr[i];\n        }\n\n    }\n    return max;\n}\n\nvoid CountingSort(int arr[],int size,int div){\n    int output[size];\n    int count[10]={0};\n\n    for (int i = 0; i &lt; size; i++)\n    {\n        count[(arr[i]/div)%10]++;\n    }\n    for (int i = 1; i &lt; 10; i++)\n    {\n        count[i]+=count[i-1];\n    }\n    for (int i = size-1; i &gt;= 0; i--)\n    {\n        output[count[(arr[i]/div)%10 ]-1]=arr[i];\n        count[(arr[i]/div)%10]--;\n    }\n    for (int i = 0; i &lt; size; i++)\n    {\n        arr[i]=output[i];\n    }\n\n}\n\nvoid radixSort(int arr[],int size){\n    int m = Getmax(arr,size);\n\n    for (int div= 1; m/div &gt;0; div*=10)\n    {\n        CountingSort(arr,size,div);\n    }\n\n}\n\nint main(){\nint size;\ncout&lt;&lt;\"Enter size of array: \";\ncin&gt;&gt;size;\n\nint arr[size];\ncout&lt;&lt;\"Enter \"&lt;&lt;size&lt;&lt;\" integers in any order : \"&lt;&lt;endl;\n\nfor(int i=0;i&lt;size;i++){\n    cin &gt;&gt; arr[i];\n}\n\nfor(int i=0;i&lt;size;i++){\n    cout&lt;&lt;arr[i]&lt;&lt;\" \";\n}\n\n    cout&lt;&lt;endl;\n    radixSort(arr,size);\n\nfor(int i=0;i&lt;size;i++){\n    cout&lt;&lt;arr[i]&lt;&lt;\" \";\n}\n    return 0;\n}\n</code></pre> <pre><code>def Getmax(arr,size):\n    max=arr[0]\n    for i in range(1,size):\n        if arr[i]&gt;max:\n            max=arr[i]\n    return max\n\ndef CountingSort(arr,size,div):\n\n    output=[0]*size\n    count=[0]*10\n\n    for i in range(0,size):\n        count[(arr[i]/div)%10]+=1\n    for i in range(1,10):\n        count[i]+=count[i-1]\n    for i in range(size-1,-1,-1):\n        output[count[(arr[i]/div)%10]-1]=arr[i]\n        count[(arr[i]/div)%10]-=1\n    for i in range(0,size):\n        arr[i]=output[i]\n\ndef radixSort(arr,size):\n    m = Getmax(arr,size)\n\n    div=1\n    while m/div &gt;0:\n        CountingSort(arr,size,div)\n        div*=10\n\nsize=int(input(\"Enter size of array: \"))\narr=[]\n\nprint(\"Enter\",size,\"integers in any order : \")\nfor i in range(0,size):\n    arr.append(int(input()))\n\nprint(\"Array before sorting: \")\nfor i in range(0,size):\n    print(arr[i],end=\" \")\n\nradixSort(arr,size)\n\nprint(\"\\nArray after sorting: \")\nfor i in range(0,size):\n    print(arr[i],end=\" \")\n</code></pre>"},{"location":"Sorting/sorting/#merge-sort","title":"Merge Sort \ud83e\udde9","text":"<p>Merge sort is a divide and conquer algorithm. It divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves. The merge() function is used for merging two halves. The merge(arr, l, m, r) is key process that assumes that arr[l..m] and arr[m+1..r] are sorted and merges the two sorted sub-arrays into one.</p>"},{"location":"Sorting/sorting/#pseudocode_4","title":"Pseudocode","text":"<pre><code>```\nmergeSort(arr[], l,  r)\nIf r &gt; l\n    1. Find the middle point to divide the array into two halves:  \n        middle m = (l+r)/2\n    2. Call mergeSort for first half:   \n        Call mergeSort(arr, l, m)\n    3. Call mergeSort for second half:\n        Call mergeSort(arr, m+1, r)\n    4. Merge the two halves sorted in step 2 and 3:\n        Call merge(arr, l, m, r)\n```\n</code></pre>"},{"location":"Sorting/sorting/#algorithm","title":"Algorithm","text":"<ol> <li>Divide the unsorted list into n sublists, each containing 1 element (a list of 1 element is considered sorted).</li> <li>Repeatedly merge sublists to produce new sorted sublists until there is only 1 sublist remaining. This will be the sorted list.</li> </ol>"},{"location":"Sorting/sorting/#example","title":"Example","text":""},{"location":"Sorting/sorting/#flowchart_4","title":"Flowchart","text":""},{"location":"Sorting/sorting/#implementation","title":"Implementation","text":"CC++Python <pre><code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n\nvoid merge(int arr[],int l,int m,int r){\n    int i,j,k;\n    int n1=m-l+1;\n    int n2=r-m;\n\n    int L[n1],R[n2];\n\n    for (i = 0; i &lt; n1; i++)\n    {\n        L[i]=arr[l+i];\n    }\n    for (j = 0; j &lt; n2; j++)\n    {\n        R[j]=arr[m+1+j];\n    }\n    i=0;\n    j=0;\n    k=l;\n\n    while (i&lt;n1 &amp;&amp; j&lt;n2)\n    {\n        if (L[i]&lt;=R[j])\n        {\n            arr[k]=L[i];\n            i++;\n        }\n        else\n        {\n            arr[k]=R[j];\n            j++;\n        }\n        k++;\n    }\n    while (i&lt;n1)\n    {\n        arr[k]=L[i];\n        i++;\n        k++;\n    }\n    while (j&lt;n2)\n    {\n        arr[k]=R[j];\n        j++;\n        k++;\n    }\n\n}\n\nvoid mergeSort(int arr[],int l,int r){\n    if (l&lt;r)\n    {\n        int m=l+(r-l)/2;\n\n        mergeSort(arr,l,m);\n        mergeSort(arr,m+1,r);\n\n        merge(arr,l,m,r);\n    }\n\n}\n\nvoid printArray(int arr[],int size){\n    for (int i = 0; i &lt; size; i++)\n    {\n        printf(\"%d \",arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main(){\n    int arr[]={12,11,13,5,6,7};\n    int size=sizeof(arr)/sizeof(arr[0]);\n\n    printf(\"Given array is \\n\");\n    printArray(arr,size);\n\n    mergeSort(arr,0,size-1);\n\n    printf(\"\\nSorted array is \\n\");\n    printArray(arr,size);\n    return 0;\n}\n</code></pre> <pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nvoid merge(int arr[],int l,int m,int r){\n    int i,j,k;\n    int n1=m-l+1;\n    int n2=r-m;\n\n    int L[n1],R[n2];\n\n    for (i = 0; i &lt; n1; i++)\n    {\n        L[i]=arr[l+i];\n    }\n    for (j = 0; j &lt; n2; j++)\n    {\n        R[j]=arr[m+1+j];\n    }\n    i=0;\n    j=0;\n    k=l;\n\n    while (i&lt;n1 &amp;&amp; j&lt;n2)\n    {\n        if (L[i]&lt;=R[j])\n        {\n            arr[k]=L[i];\n            i++;\n        }\n        else\n        {\n            arr[k]=R[j];\n            j++;\n        }\n        k++;\n    }\n    while (i&lt;n1)\n    {\n        arr[k]=L[i];\n        i++;\n        k++;\n    }\n    while (j&lt;n2)\n    {\n        arr[k]=R[j];\n        j++;\n        k++;\n    }\n\n}\n\nvoid mergeSort(int arr[],int l,int r){\n    if (l&lt;r)\n    {\n        int m=l+(r-l)/2;\n\n        mergeSort(arr,l,m);\n        mergeSort(arr,m+1,r);\n\n        merge(arr,l,m,r);\n    }\n\n}\n\nvoid printArray(int arr[],int size){\n    for (int i = 0; i &lt; size; i++)\n    {\n        cout&lt;&lt;arr[i]&lt;&lt;\" \";\n    }\n    cout&lt;&lt;endl;\n}\n\nint main(){\n    int arr[]={12,11,13,5,6,7};\n    int size=sizeof(arr)/sizeof(arr[0]);\n\n    cout&lt;&lt;\"Given array is \\n\";\n    printArray(arr,size);\n\n    mergeSort(arr,0,size-1);\n\n    cout&lt;&lt;\"\\nSorted array is \\n\";\n    printArray(arr,size);\n    return 0;\n}\n</code></pre> <pre><code>def mergeSort(arr):\n    if len(arr)&gt;1:\n        mid=len(arr)//2\n        L=arr[:mid]\n        R=arr[mid:]\n\n        mergeSort(L)\n        mergeSort(R)\n\n        i=j=k=0\n\n        while i&lt;len(L) and j&lt;len(R):\n            if L[i]&lt;R[j]:\n                arr[k]=L[i]\n                i+=1\n            else:\n                arr[k]=R[j]\n                j+=1\n            k+=1\n\n        while i&lt;len(L):\n            arr[k]=L[i]\n            i+=1\n            k+=1\n\n        while j&lt;len(R):\n            arr[k]=R[j]\n            j+=1\n            k+=1\n\ndef printList(arr):\n    for i in range(len(arr)):\n        print(arr[i],end=\" \")\n    print()\n\nif __name__==\"__main__\":\n    arr=[12,11,13,5,6,7]\n    print(\"Given array is\")\n    printList(arr)\n    mergeSort(arr)\n    print(\"Sorted array is\")\n    printList(arr)\n</code></pre> <p>output</p> <pre><code>Given array is\n12 11 13 5 6 7\nSorted array is\n5 6 7 11 12 13\n</code></pre>"},{"location":"Sorting/sorting/#time-complexity","title":"**Time Complexity  **","text":"<p>The time complexity of merge sort is O(nlogn) in all the 3 cases (worst, average and best) as merge sort always divides the array into two halves and take linear time to merge two halves.</p>"},{"location":"Sorting/sorting/#space-complexity","title":"**Space Complexity  **","text":"<p>The space complexity of merge sort is O(n) as we need to create a temporary array to store the elements while merging.</p>"},{"location":"Sorting/sorting/#applications","title":"**Applications  **","text":"<ul> <li>Merge Sort is useful for sorting linked lists in O(nLogn) time. In the case of linked lists, the case is different mainly due to the difference in memory allocation of arrays and linked lists. Unlike arrays, linked lists don\u2019t have contiguous memory locations. Due to this difference, in arrays, we can do random access as elements are contiguous in memory. Let us say we have an integer (4-byte) array A and let the address of A[0] be x then to access A[i], we can directly access the memory at (x + i*4). Unlike arrays, we can not do random access in linked lists. Quick Sort requires a lot of this kind of access. In linked list to access i\u2019th index, we have to travel each and every node from the head to i\u2019th node as we don\u2019t have a continuous block of memory. Therefore, the overhead increases for quicksort. Merge sort accesses data sequentially and the need of random access is low.</li> </ul>"},{"location":"Sorting/sorting/#shell-sort","title":"Shell Sort \ud83d\udc1a","text":"<p>Shell sort is mainly a variation of insertion sort. In insertion sort, we move elements only one position ahead. When an element has to be moved far ahead, many movements are involved. The idea of shell sort is to allow exchange of far items. In shell sort, we make the array h-sorted for a large value of h. We keep reducing the value of h until it becomes 1. An array is said to be h-sorted if all sublists of every h\u2019th element is sorted.</p>"},{"location":"Sorting/sorting/#algorithm_1","title":"**Algorithm  **","text":"<ul> <li>Choose a value for h, called the increment. Start with large values of h and work down to a value of 1.</li> <li>Divide the list into h sublists, where each sublist consists of all elements that are a distance h apart.</li> <li>Sort each sublist using an insertion sort.</li> <li>Repeat steps 2 and 3 until the list is sorted.</li> </ul>"},{"location":"Sorting/sorting/#flowchart_5","title":"Flowchart","text":""},{"location":"Sorting/sorting/#implementation_1","title":"**Implementation  **","text":"CC++ <pre><code>#include&lt;stdio.h&gt;\n\nvoid shellSort(int arr[],int n){\n    for (int gap = n/2; gap &gt; 0; gap/=2)\n    {\n        for (int i = gap; i &lt; n; i++)\n        {\n            int temp=arr[i];\n            int j=i;\n            while(j &gt;= gap &amp;&amp; arr[j-gap]&gt;temp)\n            {\n                arr[j]=arr[j-gap];\n                j-=gap;\n            }\n            arr[j]=temp;\n        }\n\n    }\n\n}\n\nvoid printArray(int arr[],int n){\n    for (int i = 0; i &lt; n; i++)\n    {\n        printf(\"%d \",arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main(){\n    int arr[]={12,34,54,2,3};\n    int n=sizeof(arr)/sizeof(arr[0]);\n\n    printf(\"Given array is \\n\");\n    printArray(arr,n);\n\n    shellSort(arr,n);\n\n    printf(\"\\nSorted array is \\n\");\n    printArray(arr,n);\n    return 0;\n}\n</code></pre> <pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nvoid shellSort(int arr[],int n){\n    for (int gap = n/2; gap &gt; 0; gap/=2)\n    {\n        for (int i = gap; i &lt; n; i++)\n        {\n            int temp=arr[i];\n            int j;\n            for (j = i; j &gt;= gap &amp;&amp; arr[j-gap]&gt;temp; j-=gap)\n            {\n                arr[j]=arr[j-gap];\n            }\n            arr[j]=temp;\n        }\n\n    }\n\n}\n\nvoid printArray(int arr[],int n){\n    for (int i = 0; i &lt; n; i++)\n    {\n        cout&lt;&lt;arr[i]&lt;&lt;\" \";\n    }\n    cout&lt;&lt;endl;\n}\n\nint main(){\n    int arr[]={12,34,54,2,3};\n    int n=sizeof(arr)/sizeof(arr[0]);\n\n    cout&lt;&lt;\"Given array is \\n\";\n    printArray(arr,n);\n\n    shellSort(arr,n);\n\n    cout&lt;&lt;\"\\nSorted array is \\n\";\n    printArray(arr,n);\n    return 0;\n}\n</code></pre>"},{"location":"Sorting/sorting/#quick-sort","title":"Quick Sort","text":"<p>Quick sort is a divide and conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot. There are many different versions of quickSort that pick pivot in different ways.</p> <ul> <li>Always pick first element as pivot.</li> <li>Always pick last element as pivot (implemented below)</li> <li>Pick a random element as pivot.</li> <li>Pick median as pivot.</li> </ul>"},{"location":"Sorting/sorting/#algorithm_2","title":"**Algorithm  **","text":"<ul> <li>Pick an element, called a pivot, from the array.</li> <li>Partitioning: reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the partition operation.</li> <li>Recursively apply the above steps to the sub-array of elements with smaller values and separately to the sub-array of elements with greater values.</li> </ul>"},{"location":"Sorting/sorting/#flowchart_6","title":"Flowchart","text":""},{"location":"Sorting/sorting/#implementation_2","title":"**Implementation  **","text":"CC++Python <pre><code>#include&lt;stdio.h&gt;\n\nvoid swap(int *a,int *b){\n    int temp=*a;\n    *a=*b;\n    *b=temp;\n}\n\nint partition(int arr[],int low,int high){\n    int pivot=arr[high];\n    int i=low-1;\n    for (int j = low; j &lt; high; j++)\n    {\n        if (arr[j]&lt;pivot)\n        {\n            i++;\n            swap(&amp;arr[i],&amp;arr[j]);\n        }\n\n    }\n    swap(&amp;arr[i+1],&amp;arr[high]);\n    return i+1;\n}\n\nvoid quickSort(int arr[],int low,int high){\n    if (low&lt;high)\n    {\n        int pi=partition(arr,low,high);\n        quickSort(arr,low,pi-1);\n        quickSort(arr,pi+1,high);\n    }\n\n}\n\nvoid printArray(int arr[],int n){\n    for (int i = 0; i &lt; n; i++)\n    {\n        printf(\"%d \",arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main(){\n    int arr[]={10,7,8,9,1,5};\n    int n=sizeof(arr)/sizeof(arr[0]);\n\n    quickSort(arr,0,n-1);\n    printf(\"Sorted array: \\n\");\n    printArray(arr,n);\n    return 0;\n}\n</code></pre> <pre><code>    #include&lt;iostream&gt;\n    using namespace std;\n\n    void swap(int *a,int *b){\n        int temp=*a;\n        *a=*b;\n        *b=temp;\n    }\n\n    int partition(int arr[],int low,int high){\n        int pivot=arr[high];\n        int i=low-1;\n        for (int j = low; j &lt; high; j++)\n        {\n            if (arr[j]&lt;pivot)\n            {\n                i++;\n                swap(&amp;arr[i],&amp;arr[j]);\n            }\n\n        }\n        swap(&amp;arr[i+1],&amp;arr[high]);\n        return i+1;\n    }\n\n    void quickSort(int arr[],int low,int high){\n        if (low&lt;high)\n        {\n            int pi=partition(arr,low,high);\n            quickSort(arr,low,pi-1);\n            quickSort(arr,pi+1,high);\n        }\n\n    }\n\n    void printArray(int arr[],int n){\n        for (int i = 0; i &lt; n; i++)\n        {\n            cout&lt;&lt;arr[i]&lt;&lt;\" \";\n        }\n        cout&lt;&lt;endl;\n    }\n\n    int main(){\n        int arr[]={10,7,8,9,1,5};\n        int n=sizeof(arr)/sizeof(arr[0]);\n\n        quickSort(arr,0,n-1);\n        cout&lt;&lt;\"Sorted array: \\n\";\n        printArray(arr,n);\n        return 0;\n    }\n</code></pre> <pre><code>    def partition(arr,low,high):\n        i=low-1\n        pivot=arr[high]\n        for j in range(low,high):\n            if arr[j]&lt;pivot:\n                i+=1\n                arr[i],arr[j]=arr[j],arr[i]\n        arr[i+1],arr[high]=arr[high],arr[i+1]\n        return i+1\n\n    def quickSort(arr,low,high):\n        if low&lt;high:\n            pi=partition(arr,low,high)\n            quickSort(arr,low,pi-1)\n            quickSort(arr,pi+1,high)\n\n    def printArray(arr):\n        for i in range(len(arr)):\n            print(arr[i],end=\" \")\n        print()\n\n    if __name__==\"__main__\":\n\n        arr=[10,7,8,9,1,5]\n        n=len(arr)\n\n        quickSort(arr,0,n-1)\n        print(\"Sorted array: \")\n        printArray(arr)\n</code></pre>"},{"location":"Sorting/sorting/#time-complexity_1","title":"**Time Complexity  **","text":"<ul> <li>Worst Case Time Complexity [ Big-O ]: O(n^2)</li> <li>Best Case Time Complexity [Big-omega]: O(n*log n)</li> <li>Average Time Complexity [Big-theta]: O(n*log n)</li> <li>Space Complexity: O(n)</li> </ul>"},{"location":"Sorting/sorting/#applications_1","title":"**Applications  **","text":"<ul> <li>Quick Sort is used in many real life applications like in sorting a deck of cards, sorting files on a disk, sorting names in a phone book, sorting student records etc.</li> </ul>"},{"location":"Sorting/sorting/#cocktail-sort","title":"**Cocktail Sort \ud83c\udf77 **","text":"<p>Cocktail Sort is a variation of Bubble sort. The Bubble sort algorithm always traverses elements from left and moves the largest element to its correct position in first iteration and second largest in second iteration and so on. Cocktail Sort traverses through a given array in both directions alternatively.</p>"},{"location":"Sorting/sorting/#algorithm_3","title":"**Algorithm  **","text":"<ul> <li>Initially, we start the loop from left side and move the largest element to the end of the array.</li> <li>Then, we start the loop from right side and move the smallest element to the beginning of the array.</li> <li>This process goes on until the array is sorted.</li> </ul>"},{"location":"Sorting/sorting/#flowchart_7","title":"Flowchart","text":""},{"location":"Sorting/sorting/#implementation_3","title":"**Implementation  **","text":"CC++ <pre><code>#include&lt;stdio.h&gt;\n\nvoid cocktailSort(int arr[],int n){\n    int swapped=1;\n    int start=0;\n    int end=n-1;\n\n    while (swapped)\n    {\n        swapped=0;\n\n        for (int i = start; i &lt; end; i++)\n        {\n            if (arr[i]&gt;arr[i+1])\n            {\n                int temp=arr[i];\n                arr[i]=arr[i+1];\n                arr[i+1]=temp;\n                swapped=1;\n            }\n        }\n\n        if (!swapped)\n        {\n            break;\n        }\n        swapped=0;\n        end--;\n\n        for (int i = end-1; i &gt;= start; i--)\n        {\n            if (arr[i]&gt;arr[i+1])\n            {\n                int temp=arr[i];\n                arr[i]=arr[i+1];\n                arr[i+1]=temp;\n                swapped=1;\n            }\n        }\n        start++;\n    }\n}\n\nvoid printArray(int arr[],int n){\n    for (int i = 0; i &lt; n; i++)\n    {\n        printf(\"%d \",arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main(){\n    int arr[]={5,1,4,2,8,0,2};\n    int n=sizeof(arr)/sizeof(arr[0]);\n\n    printf(\"Given array is \\n\");\n    printArray(arr,n);\n\n    cocktailSort(arr,n);\n\n    printf(\"\\nSorted array is \\n\");\n    printArray(arr,n);\n    return 0;\n}\n</code></pre> <pre><code>    #include&lt;bits/stdc++.h&gt;\n    using namespace std;\n\n    // Sorts array a[0..n-1] using Cocktail sort\n    void CocktailSort(int a[], int n)\n    {\n    bool swapped = true;\n    int start = 0;\n    int end = n - 1;\n\n    while (swapped) {\n    // reset the swapped flag on entering\n    // the loop, because it might be true from\n    // a previous iteration.\n    swapped = false;\n\n    // loop from left to right same as\n    // the bubble sort\n    for (int i = start; i &lt; end; ++i) {\n    if (a[i] &gt; a[i + 1]) {\n        swap(a[i], a[i + 1]);\n        swapped = true;\n    }\n    }\n\n    // if nothing moved, then array is sorted.\n    if (!swapped)\n    break;\n\n    // otherwise, reset the swapped flag so that it\n    // can be used in the next stage\n    swapped = false;\n\n    // move the end point back by one, because\n    // item at the end is in its rightful spot\n    --end;\n\n    // from right to left, doing the\n    // same comparison as in the previous stage\n    for (int i = end - 1; i &gt;= start; --i) {\n    if (a[i] &gt; a[i + 1]) {\n        swap(a[i], a[i + 1]);\n        swapped = true;\n    }\n    }\n\n    // increase the starting point, because\n    // the last stage would have moved the next\n    // smallest number to its rightful spot.\n    ++start;\n    }\n    }\n\n    /* Prints the array */\n    void printArray(int a[], int n)\n    {\n    for (int i = 0; i &lt; n; i++)\n    printf(\"%d \", a[i]);\n    printf(\"\\n\");\n    }\n\n    // Driver code\n    int main()\n    {\n    int arr[] = { 5, 1, 4, 2, 8, 0, 2 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n    CocktailSort(arr, n);\n    printf(\"Sorted array :\\n\");\n    printArray(arr, n);\n    return 0;\n    }\n</code></pre> <p>output</p> <pre><code>    Given array is\n    5 1 4 2 8 0 2\n\n    Sorted array is\n    0 1 2 2 4 5 8\n</code></pre>"},{"location":"Sorting/sorting/#time-complexity_2","title":"**Time Complexity  **","text":"<p>The time complexity of Cocktail Sort is O(n2) in worst case and O(n) in best case.</p>"},{"location":"Sorting/sorting/#space-complexity_1","title":"**Space Complexity  **","text":"<p>The space complexity of Cocktail Sort is O(1) as it is an in-place sorting algorithm.</p>"},{"location":"Sorting/sorting/#applications_2","title":"**Applications  **","text":"<ul> <li>Cocktail Sort is useful when the array is reverse sorted.</li> <li>Cocktail Sort is also useful when the array is sorted in ascending order and few elements are misplaced in the array.</li> </ul>"},{"location":"Stack/stack/","title":"Stack \ud83d\udcda","text":"<p>A stack is a data structure that follows the LIFO (Last In First Out) principle. It is a linear data structure that stores items in a similar fashion to a pile of objects. A real-world example of a stack is a stack of plates. The plate that is at the top of the pile is the first one to be removed, i.e., the plate which has been placed at the bottommost position remains in the stack for the longest period of time. The insert and delete operations are often called push and pop.</p>"},{"location":"Stack/stack/#applications-of-stack","title":"Applications of Stack","text":"<ul> <li>Balancing of symbols </li> <li>Infix to Postfix / Prefix conversion </li> <li>Redo-undo features at many places like editors, photoshop. </li> <li>Forward and backward feature in web browsers </li> <li>Used in many algorithms like Tower of Hanoi, tree traversals, stock span problem, histogram problem. </li> </ul>"},{"location":"Stack/stack/#implementation-of-stack","title":"Implementation of Stack","text":"<ul> <li>Using Array </li> <li>Using Linked List </li> </ul>"},{"location":"Stack/stack/#operations-on-stack","title":"Operations on Stack","text":"<ul> <li>Push <ul> <li>Inserting an element into the stack is called push.</li> </ul> </li> <li>Pop <ul> <li>Removing an element from the stack is called pop.</li> </ul> </li> </ul>"},{"location":"Stack/stack/#time-complexity","title":"Time Complexity","text":"<ul> <li>Push <ul> <li>O(1)</li> </ul> </li> <li>Pop <ul> <li>O(1)</li> </ul> </li> </ul>"},{"location":"Stack/stack/#space-complexity","title":"Space Complexity","text":"<ul> <li>Push <ul> <li>O(1)</li> </ul> </li> <li>Pop <ul> <li>O(1)</li> </ul> </li> </ul>"},{"location":"Stack/stack/#code","title":"Code","text":"<p>Using Array </p> CC++PythonJava <pre><code>    #include &lt;stdio.h&gt;\n    #include &lt;stdlib.h&gt;\n\n    int *stack,n,size,top=-1,i,ele,ind;\n\n    void push();\n    void pop();\n    void peek();\n\n    int main()\n    {\n        printf(\"\\n\\tStack Representation Using Array\\n\\t--------------------------------------\");\n        printf(\"\\nEnter the size of stack : \");\n        scanf(\"%d\",&amp;size);\n\n        stack = (int *)malloc(size * sizeof(int));\n\n        do\n        {\n            printf(\"\\nEnter which operation you want to perform :\\n1 : push()\\n2 : pop()\\n3 : peek()\\n4 : Stop\");\n            scanf(\"%d\",&amp;i);\n            switch (i)\n            {\n            case 1:\n                push();\n                break;\n            case 2:\n                pop();\n                break;\n            case 3:\n                peek();\n                break;\n            case 4:\n                break;\n            default:\n                printf(\"Enter valid input : 1/2/3/4\");\n                break;\n            }\n        } while (i!=4);\n\n        return 0;\n    }\n\n    void push()\n    {\n        if(top&gt;=size-1)\n        {\n            printf(\"\\nStack Overflow!\");\n        }\n        else\n        {\n            printf(\"\\nEnter element to push into Stack: \");\n            scanf(\"%d\",&amp;ele);\n            top++;\n            stack[top]=ele;\n        }\n    }\n\n    void pop()\n    {\n        if(top&lt;=-1)\n        {\n            printf(\"\\nStack Underflow!\");\n        }\n        else\n        {\n            printf(\"\\n%d is poped from stack\",stack[top]);\n            top--;\n        }\n    }\n\n    void peek()\n    {\n        if (top&gt;=0)\n        {\n            for ( i = top; i &gt;= 0; i--)\n                printf(\"\\n%d\",stack[i]);\n\n            printf(\"\\nEnter next operation : \");\n        }\n        else\n        {\n            printf(\"\\nStack is Empty!\");\n        }\n    }\n</code></pre> <pre><code>    #include &lt;iostream&gt;\n    #include &lt;stdlib.h&gt;\n\n    #define MAX 1000\n\n    int stack[MAX];\n    int top = -1;\n\n    void push(int data)\n    {\n        if (top == MAX - 1)\n        {\n            std::cout &lt;&lt; \"Stack Overflow\";\n        }\n        else\n        {\n            top++;\n            stack[top] = data;\n        }\n    }\n\n    void pop()\n    {\n        if (top == -1)\n        {\n            std::cout &lt;&lt; \"Stack Underflow\";\n        }\n        else\n        {\n            top--;\n        }\n    }\n\n    int peek()\n    {\n        if (top == -1)\n        {\n            std::cout &lt;&lt; \"Stack Underflow\";\n            return -1;\n        }\n        else\n        {\n            return stack[top];\n        }\n    }\n\n    void display()\n    {\n        if (top == -1)\n        {\n            std::cout &lt;&lt; \"Stack Underflow\";\n        }\n        else\n        {\n            for (int i = top; i &gt;= 0; i--)\n            {\n                std::cout &lt;&lt; stack[i] &lt;&lt; \" \";\n            }\n        }\n    }\n\n    int main()\n    {\n        int choice, data;\n        while (1)\n        {\n            std::cout &lt;&lt; \"\\n1. Push\";\n            std::cout &lt;&lt; \"\\n2. Pop\";\n            std::cout &lt;&lt; \"\\n3. Peek\";\n            std::cout &lt;&lt; \"\\n4. Display\";\n            std::cout &lt;&lt; \"\\n5. Exit\";\n            std::cout &lt;&lt; \"\\nEnter your choice: \";\n            std::cin &gt;&gt; choice;\n            switch (choice)\n            {\n            case 1:\n                std::cout &lt;&lt; \"Enter data: \";\n                std::cin &gt;&gt; data;\n                push(data);\n                break;\n            case 2:\n                pop();\n                break;\n            case 3:\n                std::cout &lt;&lt; \"Top element is \" &lt;&lt; peek();\n                break;\n            case 4:\n                display();\n                break;\n            case 5:\n                exit(0);\n            default:\n                std::cout &lt;&lt; \"Invalid choice\";\n            }\n        }\n        return 0;\n    }\n</code></pre> <pre><code>    stack = []\n\n    def push(data):\n        stack.append(data)\n\n    def pop():\n        if len(stack) == 0:\n            print(\"Stack Underflow\")\n        else:\n            stack.pop()\n\n    def peek():\n        if len(stack) == 0:\n            print(\"Stack Underflow\")\n        else:\n            return stack[-1]\n\n    def display():\n        if len(stack) == 0:\n            print(\"Stack Underflow\")\n        else:\n            for i in range(len(stack)-1, -1, -1):\n                print(stack[i], end=\" \")\n\n    while True:\n        print(\"\\n1. Push\")\n        print(\"2. Pop\")\n        print(\"3. Peek\")\n        print(\"4. Display\")\n        print(\"5. Exit\")\n        choice = int(input(\"Enter your choice: \"))\n        if choice == 1:\n            data = int(input(\"Enter data: \"))\n            push(data)\n        elif choice == 2:\n            pop()\n        elif choice == 3:\n            print(\"Top element is\", peek())\n        elif choice == 4:\n            display()\n        elif choice == 5:\n            break\n        else:\n            print(\"Invalid choice\")\n</code></pre> <pre><code>    import java.util.Scanner;\n\n    public class Stack {\n        static int MAX = 1000;\n        static int top = -1;\n        static int stack[] = new int[MAX];\n\n        static void push(int data) {\n            if (top == MAX - 1) {\n                System.out.println(\"Stack Overflow\");\n            } else {\n                top++;\n                stack[top] = data;\n            }\n        }\n\n        static void pop() {\n            if (top == -1) {\n                System.out.println(\"Stack Underflow\");\n            } else {\n                top--;\n            }\n        }\n\n        static int peek() {\n            if (top == -1) {\n                System.out.println(\"Stack Underflow\");\n                return -1;\n            } else {\n                return stack[top];\n            }\n        }\n\n        static void display() {\n            if (top == -1) {\n                System.out.println(\"Stack Underflow\");\n            } else {\n                for (int i = top; i &gt;= 0; i--) {\n                    System.out.print(stack[i] + \" \");\n                }\n            }\n        }\n\n        public static void main(String[] args) {\n            Scanner sc = new Scanner(System.in);\n            int choice, data;\n            while (true) {\n                System.out.println(\"\\n1. Push\");\n                System.out.println(\"2. Pop\");\n                System.out.println(\"3. Peek\");\n                System.out.println(\"4. Display\");\n                System.out.println(\"5. Exit\");\n                System.out.print(\"Enter your choice: \");\n                choice = sc.nextInt();\n                switch (choice) {\n                    case 1:\n                        System.out.print(\"Enter data: \");\n                        data = sc.nextInt();\n                        push(data);\n                        break;\n                    case 2:\n                        pop();\n                        break;\n                    case 3:\n                        System.out.println(\"Top element is \" + peek());\n                        break;\n                    case 4:\n                        display();\n                        break;\n                    case 5:\n                        System.exit(0);\n                    default:\n                        System.out.println(\"Invalid choice\");\n                }\n            }\n        }\n    }\n</code></pre>"},{"location":"Trees/Trees/","title":"Trees \ud83c\udf33\ud83c\udf34\ud83c\udf32","text":""},{"location":"Trees/Trees/#introduction","title":"Introduction","text":"<p>A tree is a data structure that consists of nodes in a parent/child relationship. A tree can be empty with no nodes or a tree is made up of nodes where each node is a data structure consisting of a value, pointer to a parent node, and an array of children nodes. A tree data structure can represent information that naturally forms a hierarchy. For example, an organization chart is a tree structure.</p>"},{"location":"Trees/Trees/#terminology","title":"Terminology","text":"<ul> <li>Root - The top node in a tree.</li> <li>Child - A node directly connected to another node when moving away from the Root.</li> <li>Parent - The converse notion of a child.</li> <li>Siblings - A group of nodes with the same parent.</li> <li>Leaf - A node with no children.</li> <li>Edge - The connection between one node and another.</li> <li>Path - A sequence of nodes and edges connecting a node with a descendant.</li> <li>Level - Level of node is the number of edges on the path from the root node to the node.</li> <li>Height - Height of node is the number of edges on the longest path from the node to a leaf + 1.</li> <li>Depth - Depth of node is the number of edges from the node to the tree's root node.</li> </ul>"},{"location":"Trees/Trees/#types-of-trees","title":"Types of Trees","text":"<ul> <li>General Tree - A tree data structure in which no node has a degree greater than two.</li> <li>Binary Tree - A tree data structure in which each node has a degree of zero,one or max two.</li> <li>Binary Search Tree - A binary tree in which the value of each node is greater than or equal to any value stored in the left sub-tree, and less than or equal to any value stored in the right sub-tree.</li> <li>Extended Binary Tree - A binary tree in which every node other than the leaves has two children.</li> <li>Complete Binary Tree - A binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.</li> </ul>"},{"location":"Trees/Trees/#binary-tree","title":"Binary Tree","text":"<p>A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child.</p>"},{"location":"Trees/Trees/#properties-of-binary-tree","title":"Properties of Binary Tree","text":"<ul> <li>The maximum number of nodes at level \u2018l\u2019 of a binary tree is 2^l.</li> <li>Maximum number of nodes in a binary tree of height \u2018h\u2019 is 2^(h) \u2013 1.</li> <li>In a Binary Tree with N nodes, minimum possible height or minimum number of levels is  Log2(N+1)</li> <li>A Binary Tree with L leaves has at least  Log2L + 1  levels</li> </ul>"},{"location":"Trees/Trees/#binary-search-tree","title":"Binary Search Tree","text":"<p>A binary search tree is a binary tree in which the value of each node is greater than or equal to any value stored in the left sub-tree, and less than or equal to any value stored in the right sub-tree.</p>"},{"location":"Trees/Trees/#properties-of-binary-search-tree","title":"Properties of Binary Search Tree","text":"<ul> <li>The left subtree of a node contains only nodes with keys less than the node\u2019s key.</li> <li>The right subtree of a node contains only nodes with keys greater than the node\u2019s key.</li> <li>The left and right subtree each must also be a binary search tree.</li> <li>There must be no duplicate nodes.</li> </ul> <ul> <li>C Program <pre><code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n\nstruct node{\n        struct node*left;\n        int data;\n        struct node*right;\n};\n\nstruct node*root=NULL;\n\nvoid insert(int data)\n{\n        struct node*newnode = (struct node*)malloc(sizeof(struct node));\n        newnode-&gt;data=data;\n        newnode-&gt;left=NULL;\n        newnode-&gt;right=NULL;\n\n        if(root == NULL)\n        {\n                root = newnode;\n        }\n        else\n        {\n                struct node*temp = root;\n                while(1)\n                {\n                        if(data &lt; temp-&gt;data)\n                        {\n                                if(temp-&gt;left == NULL)\n                                {\n                                        temp-&gt;left = newnode;\n                                        break;\n                                }\n                                else\n                                {\n                                        temp = temp-&gt;left;\n                                }\n                        }\n                        else\n                        {\n                                if(temp-&gt;right == NULL)\n                                {\n                                        temp-&gt;right = newnode;\n                                        break;\n                                }\n                                else\n                                {\n                                        temp = temp-&gt;right;\n                                }\n                        }\n                }\n        }\n}\n\nvoid search()\n{\n        int key;\n        printf(\"\\nEnter element to search :\");\n        scanf(\"%d\",&amp;key);\n        struct node*temp = root;\n                while(1)\n                {\n                        if(key &lt; temp-&gt;data)\n                        {\n                                if(temp-&gt;left == NULL)\n                                {\n                                        printf(\"\\nElement not found!\");\n                                        break;\n                                }\n                                else if(temp-&gt;left-&gt;data == key)\n                                {\n                                        printf(\"\\nElement found\");\n                                        return;\n                                }\n                                else\n                                {\n                                        temp = temp-&gt;left;\n                                }\n                        }\n                        else\n                        {\n                                if(temp-&gt;right == NULL)\n                                {\n                                        printf(\"\\nElement not found!\");\n                                        break;\n                                }\n                                else if(temp-&gt;right-&gt;data == key)\n                                {\n                                        printf(\"\\nElement found\");\n                                        return;\n                                }\n                                else\n                                {\n                                        temp = temp-&gt;right;\n                                }\n                        }\n                }\n}\n\nint main()\n{\n        int key,data,n;\n        printf(\"\\nEnter how many numbers you want to insert: \");\n        scanf(\"%d\",&amp;n);\n        for(int i=0;i&lt;n;i++)\n        {\n                printf(\"\\nEnter data : \");\n                scanf(\"%d\",&amp;data);\n                insert(data);\n        }\n        search();\n}\n</code></pre></li> <li>Output <pre><code>Enter how many numbers you want to insert: 6\n\nEnter data : 3\n\nEnter data : 1\n\nEnter data : 6\n\nEnter data : 4\n\nEnter data : 2\n\nEnter data : 9\n\nEnter element to search :4\n\nElement found\n</code></pre></li> </ul>"},{"location":"Trees/Trees/#complete-binary-tree","title":"Complete Binary Tree","text":"<p>A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.</p> <p>Complete Binary tree looks like :        </p>"},{"location":"Trees/Trees/#extended-binary-tree","title":"Extended Binary Tree","text":"<p>An extended binary tree is a binary tree in which every node other than the leaves has two children.</p> <p>General tree can be converted to extended binary tree by adding dummy nodes.</p> <p>Converting General tree to extended binary tree :         </p>"},{"location":"Trees/Trees/#representation-of-binary-trees-in-memory","title":"Representation of Binary trees in memory","text":""},{"location":"Trees/Trees/#1link","title":"1.Link","text":""},{"location":"Trees/Trees/#2sequential","title":"2.Sequential","text":""},{"location":"Trees/Trees/#linked-representation","title":"Linked Representation","text":"<p>.           </p>"},{"location":"Trees/Trees/#chart-form-of-above-presentation","title":"Chart form of above presentation","text":"Sr.No left Info Right 1 -1 K -1 2 3 E -1 3 -1 Y 4 4 -1 H -1 5 1 T 6 6 8 S -1 7 2 D 5 8 -1 J -1 ---"},{"location":"Trees/Trees/#sequential-representation","title":"Sequential Representation","text":"<p>.     </p>"},{"location":"Trees/Trees/#rules","title":"Rules :","text":"<ol> <li>OneDirectional array called tree is used to store elements of tree.</li> <li> <p>The root of the tree will be at first index(instead of 0)          i.e. tree[1] will store root node of tree</p> </li> <li> <p>Children of node stored in location 2k (left node) and          2k+1 (right node).........(k = parent node)</p> </li> <li> <p>Maximum size of array \"tree\" is given as 2^h - 1</p> </li> <li> <p>An empty tree or subtree is specified by NULL         i.e. tree[1]=NULL</p> </li> </ol>"},{"location":"Trees/Trees/#expression-tree","title":"Expression Tree \ud83c\udf32\u204e\u2055/\u2013\ud83c\udf32","text":""},{"location":"Trees/Trees/#used-for-representing-an-equation","title":"Used for representing an equation","text":"<p>eg. 3+(5+9)*2 </p> <p></p>"},{"location":"Trees/Trees/#traversing-binary-tree","title":"Traversing Binary Tree \ud83e\udef1\ud83c\udffb\u200d\ud83e\udef2\ud83c\udffb","text":""},{"location":"Trees/Trees/#preorder-traversal","title":"Preorder Traversal","text":"<ol> <li>Visit the root.</li> <li>Traverse the left subtree, i.e., call Preorder(left-subtree)</li> <li>Traverse the right subtree, i.e., call Preorder(right-subtree)</li> </ol>"},{"location":"Trees/Trees/#inorder-traversal","title":"Inorder Traversal","text":"<ol> <li>Traverse the left subtree, i.e., call Inorder(left-subtree)</li> <li>Visit the root.</li> <li>Traverse the right subtree, i.e., call Inorder(right-subtree)</li> </ol>"},{"location":"Trees/Trees/#postorder-traversal","title":"Postorder Traversal","text":"<ol> <li>Traverse the left subtree, i.e., call Postorder(left-subtree)</li> <li>Traverse the right subtree, i.e., call Postorder(right-subtree)</li> <li>Visit the root.</li> </ol> <pre><code>         6\n        / \\\n       /   \\\n      /     \\\n     1       7\n    / \\       \\\n   0   2       8\n        \\       \\\n         5       9\n</code></pre> <p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct node\n{\n        struct node* left;\n        int data;\n        struct node* right;\n};\n\nstruct node*root=NULL;\n\nvoid insert(int data)\n{\n        struct node*newnode = (struct node*)malloc(sizeof(struct node));\n        newnode-&gt;data=data;\n        newnode-&gt;left=NULL;\n        newnode-&gt;right=NULL;\n\n        if(root == NULL)\n        {\n                root = newnode;\n        }\n        else\n        {\n                struct node*temp = root;\n                while(1)\n                {\n                        if(data &lt; temp-&gt;data)\n                        {\n                                if(temp-&gt;left == NULL)\n                                {\n                                        temp-&gt;left = newnode;\n                                        break;\n                                }\n                                else\n                                {\n                                        temp = temp-&gt;left;\n                                }\n                        }\n                        else\n                        {\n                                if(temp-&gt;right == NULL)\n                                {\n                                        temp-&gt;right = newnode;\n                                        break;\n                                }\n                                else\n                                {\n                                        temp = temp-&gt;right;\n                                }\n                        }\n                }\n        }\n}\n\nvoid preorder(struct node* temp)\n{\n     if(temp!=NULL)\n     {\n        printf(\"%d\",&amp;temp-&gt;data);\n        preorder(temp-&gt;left);\n        preorder(temp-&gt;right);\n     }   \n}\n\nvoid inorder(struct node* temp)\n{\n     if(temp!=NULL)\n     {\n        preorder(temp-&gt;left);\n        printf(\"%d\",&amp;temp-&gt;data);\n        preorder(temp-&gt;right);\n     }   \n}\n\nvoid postorder(struct node* temp)\n{\n     if(temp!=NULL)\n     {\n        preorder(temp-&gt;left);\n        preorder(temp-&gt;right);\n        printf(\"%d\",&amp;temp-&gt;data);\n     }   \n}\n\nint main()\n{\n        int n,data;\n        printf(\"Enter number of nodes :\");\n        scanf(\"%d\",&amp;n);\n\n        for(int i=0;i&lt;n;i++)\n        {\n                printf(\"\\nEnter data : \");\n                scanf(\"%d\",&amp;data);\n                insert(data);\n        }\n        printf(\"\\nPreoder : \");\n        preorder(root);\n        printf(\"\\nInoder : \");\n        inorder(root);\n        printf(\"\\nPostoder : \");\n        postorder(root);\n\n        return 0;\n}\n</code></pre> - Output <pre><code>Enter number of nodes :8\n\nEnter data : 6\n\nEnter data : 1\n\nEnter data : 7\n\nEnter data : 0\n\nEnter data : 2\n\nEnter data : 8\n\nEnter data : 5\n\nEnter data : 9\n\nPreoder : 6 1 0 2 5 7 8 9 \nInoder : 1 0 2 5 6 7 8 9 \nPostoder : 1 0 2 5 7 8 9 6 \n</code></pre></p>"},{"location":"Trees/Trees/#bfs","title":"BFS","text":""},{"location":"Trees/Trees/#level-order-traversal","title":"Level Order Traversal","text":"<ol> <li>Create an empty queue q</li> <li>temp_node = root /start from root/</li> <li>Loop while temp_node is not NULL     a. print temp_node-&gt;data.     b. Enqueue temp_node\u2019s children (first left then right children) to q     c. Dequeue a node from q and assign it\u2019s value to temp_node</li> </ol>"},{"location":"Trees/Trees/#spiral-order-traversal","title":"Spiral Order Traversal","text":"<ol> <li>Create an empty queue q</li> <li>temp_node = root /start from root/</li> <li>Loop while temp_node is not NULL     a. print temp_node-&gt;data.     b. Enqueue temp_node\u2019s children (first right then left children) to q     c. Dequeue a node from q and assign it\u2019s value to temp_node</li> </ol>"},{"location":"Trees/Trees/#reverse-level-order-traversal","title":"Reverse Level Order Traversal","text":"<ol> <li>Create an empty queue q</li> <li>temp_node = root /start from root/</li> <li>Loop while temp_node is not NULL     a. print temp_node-&gt;data.     b. Enqueue temp_node\u2019s children (first right then left children) to q     c. Dequeue a node from q and assign it\u2019s value to temp_node</li> </ol>"},{"location":"Trees/Trees/#zigzag-order-traversal","title":"ZigZag Order Traversal","text":"<ol> <li>Create an empty queue q</li> <li>temp_node = root /start from root/</li> <li>Loop while temp_node is not NULL     a. print temp_node-&gt;data.     b. Enqueue temp_node\u2019s children (first right then left children) to q     c. Dequeue a node from q and assign it\u2019s value to temp_node</li> </ol>"},{"location":"Trees/Trees/#bfs-algorithm-applications","title":"BFS Algorithm Applications","text":"<ul> <li>To build index by search index</li> <li>For GPS navigation</li> <li>Path finding algorithms</li> <li>In Ford-Fulkerson algorithm to find maximum flow in a network</li> <li>Cycle detection in an undirected graph</li> <li>In minimum spanning tree</li> </ul>"},{"location":"Trees/Trees/#dfs","title":"DFS","text":""},{"location":"Trees/Trees/#inorder-traversal_1","title":"Inorder Traversal","text":"<ol> <li>Create an empty stack S.</li> <li>Initialize current node as root</li> <li>Push the current node to S and set current = current-&gt;left until current is NULL</li> <li>If current is NULL and stack is not empty then      a. Pop the top item from stack.     b. Print the popped item, set current = popped_item-&gt;right      c. Go to step 3.</li> <li>If current is NULL and stack is empty then we are done.</li> </ol>"},{"location":"Trees/Trees/#preorder-traversal_1","title":"Preorder Traversal","text":"<ol> <li>Create an empty stack S.</li> <li>Initialize current node as root</li> <li>Push the current node to S and set current = current-&gt;left until current is NULL</li> <li>If current is NULL and stack is not empty then      a. Pop the top item from stack.     b. Print the popped item, set current = popped_item-&gt;right      c. Go to step 3.</li> <li>If current is NULL and stack is empty then we are done.</li> </ol>"},{"location":"Trees/Trees/#postorder-traversal_1","title":"Postorder Traversal","text":"<ol> <li>Create an empty stack S.</li> <li>Initialize current node as root</li> <li>Push the current node to S and set current = current-&gt;left until current is NULL</li> <li>If current is NULL and stack is not empty then      a. Pop the top item from stack.     b. Print the popped item, set current = popped_item-&gt;right      c. Go to step 3.</li> <li>If current is NULL and stack is empty then we are done.</li> </ol>"},{"location":"Trees/Trees/#application-of-dfs-algorithm","title":"Application of DFS Algorithm","text":"<ul> <li>For finding the path</li> <li>To test if the graph is bipartite</li> <li>For finding the strongly connected components of a graph</li> <li>For detecting cycles in a graph</li> </ul>"},{"location":"intro/","title":"\ud83d\udea7 Work In Progress","text":""},{"location":"programs/","title":"Here are some programs that you can use to learn more about the language and data structures. \ud83d\ude0e","text":""},{"location":"programs/#1hello-world","title":"1.Hello world","text":"<pre><code>    #include &lt;stdio.h&gt;\n\n    int main(void)\n    {\n        printf(\"hello, world\");\n    }\n</code></pre>"},{"location":"programs/#2program-to-assign-values-of-two-numbers-and-print-their-addition","title":"2.Program to assign values of two numbers and print their addition.","text":"<pre><code>    #include&lt;stdio.h&gt;\n    #include&lt;conio.h&gt;\n\n    void main()\n    {\n    int a=10,b=20;\n    clrscr();\n\n    int ans = a + b;\n\n    printf(\"Addition is : %d\",ans);\n\n    getch();\n    }\n</code></pre>"},{"location":"programs/#3program-to-print-simple-interest","title":"3.Program to print simple interest.","text":"<pre><code>    #include&lt;stdio.h&gt;\n    #include&lt;conio.h&gt;\n\n    void main()\n    {\n    int p=1000,r=5,t=2;\n    clrscr();\n\n    int si = (p*r*t)/100;\n\n    printf(\"Simple Interest is : %d\",si);\n\n    getch();\n    }\n</code></pre>"},{"location":"programs/#4program-to-print-area-of-a-circle","title":"4.Program to print area of a circle.","text":"<pre><code>    #include&lt;stdio.h&gt;\n    #include&lt;conio.h&gt;\n\n    void main()\n    {\n    int r=5;\n    clrscr();\n\n    float area = 3.14*r*r;\n\n    printf(\"Area of circle is : %f\",area);\n\n    getch();\n    }\n</code></pre>"},{"location":"programs/#5program-to-print-area-of-a-rectangle","title":"5.Program to print area of a rectangle.","text":"<pre><code>    #include&lt;stdio.h&gt;\n    #include&lt;conio.h&gt;\n\n    void main()\n    {\n    int l=5,b=10;\n    clrscr();\n\n    int area = l*b;\n\n    printf(\"Area of rectangle is : %d\",area);\n\n    getch();\n    }\n</code></pre>"},{"location":"programs/#6program-to-print-area-of-a-triangle","title":"6.Program to print area of a triangle.","text":"<pre><code>    #include&lt;stdio.h&gt;\n    #include&lt;conio.h&gt;\n\n    void main()\n    {\n    int b=10,h=5;\n    clrscr();\n\n    float area = 0.5*b*h;\n\n    printf(\"Area of triangle is : %f\",area);\n\n    getch();\n    }\n</code></pre>"},{"location":"programs/#7program-to-print-area-of-a-square","title":"7.Program to print area of a square.","text":"<pre><code>    #include&lt;stdio.h&gt;\n    #include&lt;conio.h&gt;\n\n    void main()\n    {\n    int s=5;\n    clrscr();\n\n    int area = s*s;\n\n    printf(\"Area of square is : %d\",area);\n\n    getch();\n    }\n</code></pre>"},{"location":"programs/#8program-to-accept-two-number-and-print-largest-among-them","title":"8.Program to accept two number and print largest among them.","text":"<pre><code>    #include&lt;stdio.h&gt;\n    #include&lt;conio.h&gt;\n\n    void main()\n    {\n    int a=10,b=20;\n    clrscr();\n\n    if(a&gt;b)\n    {\n    printf(\"a is greater\");\n    }\n    else\n    {\n    printf(\"b is greater\");\n    }\n\n    getch();\n    }\n</code></pre>"},{"location":"programs/#9program-to-accept-two-number-and-print-smallest-among-them","title":"9.Program to accept two number and print smallest among them.","text":"<pre><code>    #include&lt;stdio.h&gt;\n    #include&lt;conio.h&gt;\n\n    void main()\n    {\n    int a=10,b=20;\n    clrscr();\n\n    if(a&lt;b)\n    {\n    printf(\"a is smaller\");\n    }\n    else\n    {\n    printf(\"b is smaller\");\n    }\n\n    getch();\n    }\n</code></pre>"},{"location":"programs/#10-program-to-accept-three-numbers-from-user-and-print-them-in-ascending-and-decending-order","title":"10. Program to accept three numbers from user and print them in ascending and decending order.","text":"<pre><code>    #include&lt;stdio.h&gt;\n    #include&lt;conio.h&gt;\n\n    void main()\n    {\n    int a=10,b=20,c=30;\n    clrscr();\n\n    if(a&gt;b &amp;&amp; a&gt;c)\n    {\n    if(b&gt;c)\n    {\n    printf(\"a&gt;b&gt;c\");\n    }\n    else\n    {\n    printf(\"a&gt;c&gt;b\");\n    }\n    }\n    else if(b&gt;a &amp;&amp; b&gt;c)\n    {\n    if(a&gt;c)\n    {\n    printf(\"b&gt;a&gt;c\");\n    }\n    else\n    {\n    printf(\"b&gt;c&gt;a\");\n    }\n    }\n    else\n    {\n    if(a&gt;b)\n    {\n    printf(\"c&gt;a&gt;b\");\n    }\n    else\n    {\n    printf(\"c&gt;b&gt;a\");\n    }\n    }\n\n    getch();\n    }\n</code></pre>"},{"location":"programs/#11program-to-accept-a-number-and-print-whether-it-is-even-or-odd","title":"11.Program to accept a number and print whether it is even or odd.","text":"<pre><code>    #include&lt;stdio.h&gt;\n    #include&lt;conio.h&gt;\n\n    void main()\n    {\n    int a=10;\n    clrscr();\n\n    if(a%2==0)\n    {\n    printf(\"a is even\");\n    }\n    else\n    {\n    printf(\"a is odd\");\n    }\n\n    getch();\n    }\n</code></pre>"},{"location":"programs/#12program-to-accept-a-number-and-print-whether-it-is-positive-or-negative","title":"12.Program to accept a number and print whether it is positive or negative.","text":"<pre><code>    #include&lt;stdio.h&gt;\n    #include&lt;conio.h&gt;\n\n    void main()\n    {\n    int a=10;\n    clrscr();\n\n    if(a&gt;0)\n    {\n    printf(\"a is positive\");\n    }\n    else\n    {\n    printf(\"a is negative\");\n    }\n\n    getch();\n    }\n</code></pre>"},{"location":"programs/#13program-to-accept-a-number-and-print-whether-it-is-prime-or-not","title":"13.Program to accept a number and print whether it is prime or not.","text":"<pre><code>    #include&lt;stdio.h&gt;\n    #include&lt;conio.h&gt;\n\n    void main()\n    {\n    int a=10;\n    clrscr();\n\n    int i,flag=0;\n\n    for(i=2;i&lt;a;i++)\n    {\n    if(a%i==0)\n    {\n    flag=1;\n    break;\n    }\n    }\n\n    if(flag==0)\n    {\n    printf(\"a is prime\");\n    }\n    else\n    {\n    printf(\"a is not prime\");\n    }\n\n    getch();\n    }\n</code></pre>"},{"location":"programs/#14program-to-accept-a-number-and-print-whether-it-is-palindrome-or-not","title":"14.Program to accept a number and print whether it is palindrome or not.","text":"<pre><code>    #include&lt;stdio.h&gt;\n    #include&lt;conio.h&gt;\n\n    void main()\n    {\n    int a=121;\n    clrscr();\n\n    int temp=a,rev=0;\n\n    while(temp!=0)\n    {\n    rev=rev*10+temp%10;\n    temp=temp/10;\n    }\n\n    if(rev==a)\n    {\n    printf(\"a is palindrome\");\n    }\n    else\n    {\n    printf(\"a is not palindrome\");\n    }\n\n    getch();\n    }\n</code></pre>"},{"location":"programs/#15program-to-accept-a-number-and-print-whether-it-is-armstrong-or-not","title":"15.Program to accept a number and print whether it is armstrong or not.","text":"<pre><code>    #include&lt;stdio.h&gt;\n    #include&lt;conio.h&gt;\n\n    void main()\n    {\n    int a=153;\n    clrscr();\n\n    int temp=a,rev=0;\n\n    while(temp!=0)\n    {\n    rev=rev*10+temp%10;\n    temp=temp/10;\n    }\n\n    if(rev==a)\n    {\n    printf(\"a is armstrong\");\n    }\n    else\n    {\n    printf(\"a is not armstrong\");\n    }\n\n    getch();\n    }\n</code></pre>"},{"location":"programs/#16program-to-accept-a-number-and-print-whether-it-is-perfect-or-not","title":"16.Program to accept a number and print whether it is perfect or not.","text":"<pre><code>    #include&lt;stdio.h&gt;\n    #include&lt;conio.h&gt;\n\n    void main()\n    {\n    int a=6;\n    clrscr();\n\n    int i,sum=0;\n\n    for(i=1;i&lt;a;i++)\n    {\n    if(a%i==0)\n    {\n    sum=sum+i;\n    }\n    }\n\n    if(sum==a)\n    {\n    printf(\"a is perfect\");\n    }\n    else\n    {\n    printf(\"a is not perfect\");\n    }\n\n    getch();\n    }\n</code></pre>"},{"location":"programs/#17-program-to-find-the-roots-of-a-quadratic-equation","title":"17. Program to find the roots of a quadratic equation.","text":"<pre><code>    #include&lt;stdio.h&gt;\n    #include&lt;conio.h&gt;\n    #include&lt;math.h&gt;\n\n    void main()\n    {\n    int a=1,b=5,c=6;\n    clrscr();\n\n    int d=b*b-4*a*c;\n\n    if(d&gt;0)\n    {\n    printf(\"Roots are real and unequal\");\n    }\n    else if(d==0)\n    {\n    printf(\"Roots are real and equal\");\n    }\n    else\n    {\n    printf(\"Roots are imaginary\");\n    }\n\n    getch();\n    }\n</code></pre>"},{"location":"programs/#18pattern-1","title":"18.Pattern 1","text":"<pre><code>    \u2022\n    \u2022 \u2022\n    \u2022 \u2022 \u2022\n    \u2022 \u2022 \u2022 \u2022\n    \u2022 \u2022 \u2022 \u2022 \u2022\n</code></pre> <pre><code>    #include&lt;stdio.h&gt;\n    #include&lt;conio.h&gt;\n\n    void main()\n    {\n    int i,j;\n    clrscr();\n\n    for(i=1;i&lt;=5;i++)\n    {\n    for(j=1;j&lt;=i;j++)\n    {\n    printf(\"\u2022 \");\n    }\n    printf(\"\\n\");\n    }\n\n    getch();\n    }\n</code></pre>"},{"location":"programs/#19pattern-2","title":"19.Pattern 2","text":"<pre><code>    \u2022 \u2022 \u2022 \u2022 \u2022\n    \u2022 \u2022 \u2022 \u2022\n    \u2022 \u2022 \u2022\n    \u2022 \u2022\n    \u2022\n</code></pre> <pre><code>    #include&lt;stdio.h&gt;\n    #include&lt;conio.h&gt;\n\n    void main()\n    {\n    int i,j;\n    clrscr();\n\n    for(i=5;i&gt;=1;i--)\n    {\n    for(j=1;j&lt;=i;j++)\n    {\n    printf(\"\u2022 \");\n    }\n    printf(\"\\n\");\n    }\n\n    getch();\n    }\n</code></pre>"},{"location":"programs/#20pattern-3","title":"20.Pattern 3","text":"<pre><code>     \u2022\n    \u2022 \u2022\n   \u2022 \u2022 \u2022\n  \u2022 \u2022 \u2022 \u2022\n \u2022 \u2022 \u2022 \u2022 \u2022\n</code></pre> <pre><code>    #include&lt;stdio.h&gt;\n    #include&lt;conio.h&gt;\n\n    void main()\n    {\n        char ch = '\u2022';\n        int n,i, j, no_of_spaces = 0, spaceCount;\n\n        printf(\"Enter number : \");\n        scanf(\"%d\", &amp;n);\n        printf(\"\\n\");\n        no_of_spaces = n - 1;\n\n        for (i = 1; i &lt;= n; i++)\n        {\n            for (spaceCount = no_of_spaces; spaceCount &gt;= 1; spaceCount--)\n            {\n                printf(\"  \");\n            }\n            for (j = 1; j &lt;= i; j++)\n            {\n                printf(\"%2c\", ch);\n            }\n            printf(\"\\n\");\n            no_of_spaces--;\n        }\n        getch();\n    }\n</code></pre>"}]}